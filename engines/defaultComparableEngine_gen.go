// Code generated by genlib3. DO NOT EDIT

package stdeng

import (
	"context"

	"gorgonia.org/tensor"
	"gorgonia.org/tensor/internal/errors"
)

// ElEq performs `a == b`, with a bool tensor as the return value. If`asSameDT == true`, an error will be returned.
func (e compComparableEng[DT, T]) ElEq(ctx context.Context, a, b tensor.Basic[DT], retVal DescWithStorage, asSameDT bool) (err error) {
	op := eleqOp[DT]()
	if asSameDT {
		var v DT
		return errors.Errorf("Unable to perform %v for data type %T", errors.ThisFn(), v)
	}
	return e.CmpOp(ctx, a, b, retVal.(tensor.Basic[bool]), op)
}

// ElEq performs `vec == scalar` or `scalar == vec`, with a bool tensor as the return value. The `scalarOnLeft` parameter indicates
// if the scalar value is on the left of the bin op. If `asSameDT` == true, an error will be returned.
func (e compComparableEng[DT, T]) ElEqScalar(ctx context.Context, a tensor.Basic[DT], b DT, retVal DescWithStorage, scalarOnLeft bool, asSameDT bool) (err error) {
	op := eleqOp[DT]()
	if asSameDT {
		var v DT
		return errors.Errorf("Unable to perform %v for data type %T", errors.ThisFn(), v)
	}
	return e.CmpOpScalar(ctx, a, b, retVal.(tensor.Basic[bool]), scalarOnLeft, op)
}

// ElEqBroadcastable performs `a == b`, with a bool tensor as the return value. The operation is broadacasted correctly according to shape. If`asSameDT == true`, an error will be returned.
func (e compComparableEng[DT, T]) ElEqBroadcastable(ctx context.Context, a, b tensor.Basic[DT], retVal DescWithStorage, asSameDT bool, expAPA, expAPB *tensor.AP) (err error) {
	op := eleqOp[DT]()
	if asSameDT {
		var v DT
		return errors.Errorf("Unable to perform %v for data type %T", errors.ThisFn(), v)
	}
	return e.CmpOpBC(ctx, a, b, retVal.(tensor.Basic[bool]), expAPA, expAPB, op)
}

// ElNe performs `a != b`, with a bool tensor as the return value. If`asSameDT == true`, an error will be returned.
func (e compComparableEng[DT, T]) ElNe(ctx context.Context, a, b tensor.Basic[DT], retVal DescWithStorage, asSameDT bool) (err error) {
	op := elneOp[DT]()
	if asSameDT {
		var v DT
		return errors.Errorf("Unable to perform %v for data type %T", errors.ThisFn(), v)
	}
	return e.CmpOp(ctx, a, b, retVal.(tensor.Basic[bool]), op)
}

// ElNe performs `vec != scalar` or `scalar != vec`, with a bool tensor as the return value. The `scalarOnLeft` parameter indicates
// if the scalar value is on the left of the bin op. If `asSameDT` == true, an error will be returned.
func (e compComparableEng[DT, T]) ElNeScalar(ctx context.Context, a tensor.Basic[DT], b DT, retVal DescWithStorage, scalarOnLeft bool, asSameDT bool) (err error) {
	op := eleqOp[DT]()
	if asSameDT {
		var v DT
		return errors.Errorf("Unable to perform %v for data type %T", errors.ThisFn(), v)
	}
	return e.CmpOpScalar(ctx, a, b, retVal.(tensor.Basic[bool]), scalarOnLeft, op)
}

// ElNeBroadcastable performs `a != b`, with a bool tensor as the return value. The operation is broadacasted correctly according to shape. If`asSameDT == true`, an error will be returned.
func (e compComparableEng[DT, T]) ElNeBroadcastable(ctx context.Context, a, b tensor.Basic[DT], retVal DescWithStorage, asSameDT bool, expAPA, expAPB *tensor.AP) (err error) {
	op := elneOp[DT]()
	if asSameDT {
		var v DT
		return errors.Errorf("Unable to perform %v for data type %T", errors.ThisFn(), v)
	}
	return e.CmpOpBC(ctx, a, b, retVal.(tensor.Basic[bool]), expAPA, expAPB, op)
}
