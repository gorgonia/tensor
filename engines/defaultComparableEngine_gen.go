// Code generated by genlib3. DO NOT EDIT

package stdeng

import (
	"context"

	"gorgonia.org/tensor"
	"gorgonia.org/tensor/internal/errors"
)

// ElEq performs `a == b`, with a bool tensor as the return value. If`asSameDT == true`, an error will be returned.
func (e compComparableEng[DT, T]) ElEq(ctx context.Context, a, b T, retVal DescWithStorage, asSameDT bool) (err error) {
	op := eleqOp[DT]()
	if asSameDT {
		var v DT
		return errors.Errorf("Unable to perform %v for data type %T", errors.ThisFn(), v)
	}
	return e.CmpOp(ctx, a, b, retVal.(tensor.Basic[bool]), op)
}

// ElEq performs `vec == scalar` or `scalar == vec`, with a bool tensor as the return value. The `scalarOnLeft` parameter indicates
// if the scalar value is on the left of the bin op. If `asSameDT` == true, an error will be returned.
func (e compComparableEng[DT, T]) ElEqScalar(ctx context.Context, a T, b DT, retVal DescWithStorage, scalarOnLeft bool, asSameDT bool) (err error) {
	op := eleqOp[DT]()
	if asSameDT {
		var v DT
		return errors.Errorf("Unable to perform %v for data type %T", errors.ThisFn(), v)
	}
	return e.CmpOpScalar(ctx, a, b, retVal.(tensor.Basic[bool]), scalarOnLeft, op)
}

// ElEqBroadcastable performs `a == b`, with a bool tensor as the return value. The operation is broadacasted correctly according to shape. If`asSameDT == true`, an error will be returned.
func (e compComparableEng[DT, T]) ElEqBroadcastable(ctx context.Context, a, b T, retVal DescWithStorage, asSameDT bool, expAPA, expAPB *tensor.AP) (err error) {
	op := eleqOp[DT]()
	if asSameDT {
		var v DT
		return errors.Errorf("Unable to perform %v for data type %T", errors.ThisFn(), v)
	}
	return e.CmpOpBC(ctx, a, b, retVal.(tensor.Basic[bool]), expAPA, expAPB, op)
}

// Ne performs `a != b`, with a bool tensor as the return value. If`asSameDT == true`, an error will be returned.
func (e compComparableEng[DT, T]) Ne(ctx context.Context, a, b T, retVal DescWithStorage, asSameDT bool) (err error) {
	op := neOp[DT]()
	if asSameDT {
		var v DT
		return errors.Errorf("Unable to perform %v for data type %T", errors.ThisFn(), v)
	}
	return e.CmpOp(ctx, a, b, retVal.(tensor.Basic[bool]), op)
}

// Ne performs `vec != scalar` or `scalar != vec`, with a bool tensor as the return value. The `scalarOnLeft` parameter indicates
// if the scalar value is on the left of the bin op. If `asSameDT` == true, an error will be returned.
func (e compComparableEng[DT, T]) NeScalar(ctx context.Context, a T, b DT, retVal DescWithStorage, scalarOnLeft bool, asSameDT bool) (err error) {
	op := eleqOp[DT]()
	if asSameDT {
		var v DT
		return errors.Errorf("Unable to perform %v for data type %T", errors.ThisFn(), v)
	}
	return e.CmpOpScalar(ctx, a, b, retVal.(tensor.Basic[bool]), scalarOnLeft, op)
}

// NeBroadcastable performs `a != b`, with a bool tensor as the return value. The operation is broadacasted correctly according to shape. If`asSameDT == true`, an error will be returned.
func (e compComparableEng[DT, T]) NeBroadcastable(ctx context.Context, a, b T, retVal DescWithStorage, asSameDT bool, expAPA, expAPB *tensor.AP) (err error) {
	op := neOp[DT]()
	if asSameDT {
		var v DT
		return errors.Errorf("Unable to perform %v for data type %T", errors.ThisFn(), v)
	}
	return e.CmpOpBC(ctx, a, b, retVal.(tensor.Basic[bool]), expAPA, expAPB, op)
}
