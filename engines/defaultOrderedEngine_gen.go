// Code generated by genlib3. DO NOT EDIT

package stdeng

import (
	"context"

	"gorgonia.org/tensor"
	"gorgonia.org/tensor/internal/errors"
)

// Lt performs `a < b`, with a bool tensor as the return value. If`asSameDT == true`, an error will be returned.
func (e OrderedEng[DT, T]) Lt(ctx context.Context, a, b tensor.Basic[DT], retVal DescWithStorage, asSameDT bool) (err error) {
	op := ltOp[DT]()
	if asSameDT {
		var v DT
		return errors.Errorf("Unable to perform %v for data type %T", errors.ThisFn(), v)
	}
	return e.CmpOp(ctx, a, b, retVal.(tensor.Basic[bool]), op)
}

// LtScalar performs `vec < scalar` or `scalar < vec`, with a bool tensor as the return value. The `scalarOnLeft` parameter indicates
// if the scalar value is on the left of the bin op. If `asSameDT` == true, an error will be returned.
func (e OrderedEng[DT, T]) LtScalar(ctx context.Context, a tensor.Basic[DT], b DT, retVal DescWithStorage, scalarOnLeft bool, asSameDT bool) (err error) {
	op := ltOp[DT]()
	if asSameDT {
		var v DT
		return errors.Errorf("Unable to perform %v for data type %T", errors.ThisFn(), v)
	}
	return e.CmpOpScalar(ctx, a, b, retVal.(tensor.Basic[bool]), scalarOnLeft, op)
}

// LtBroadcastable performs `a < b`, with a bool tensor as the return value. The operation is broadacasted correctly according to shape. If`asSameDT == true`, an error will be returned.
func (e OrderedEng[DT, T]) LtBroadcastable(ctx context.Context, a, b tensor.Basic[DT], retVal DescWithStorage, asSameDT bool, expAPA, expAPB *tensor.AP) (err error) {
	op := ltOp[DT]()
	if asSameDT {
		var v DT
		return errors.Errorf("Unable to perform %v for data type %T", errors.ThisFn(), v)
	}
	return e.CmpOpBC(ctx, a, b, retVal.(tensor.Basic[bool]), expAPA, expAPB, op)
}

// Lte performs `a <= b`, with a bool tensor as the return value. If`asSameDT == true`, an error will be returned.
func (e OrderedEng[DT, T]) Lte(ctx context.Context, a, b tensor.Basic[DT], retVal DescWithStorage, asSameDT bool) (err error) {
	op := lteOp[DT]()
	if asSameDT {
		var v DT
		return errors.Errorf("Unable to perform %v for data type %T", errors.ThisFn(), v)
	}
	return e.CmpOp(ctx, a, b, retVal.(tensor.Basic[bool]), op)
}

// LteScalar performs `vec <= scalar` or `scalar <= vec`, with a bool tensor as the return value. The `scalarOnLeft` parameter indicates
// if the scalar value is on the left of the bin op. If `asSameDT` == true, an error will be returned.
func (e OrderedEng[DT, T]) LteScalar(ctx context.Context, a tensor.Basic[DT], b DT, retVal DescWithStorage, scalarOnLeft bool, asSameDT bool) (err error) {
	op := lteOp[DT]()
	if asSameDT {
		var v DT
		return errors.Errorf("Unable to perform %v for data type %T", errors.ThisFn(), v)
	}
	return e.CmpOpScalar(ctx, a, b, retVal.(tensor.Basic[bool]), scalarOnLeft, op)
}

// LteBroadcastable performs `a <= b`, with a bool tensor as the return value. The operation is broadacasted correctly according to shape. If`asSameDT == true`, an error will be returned.
func (e OrderedEng[DT, T]) LteBroadcastable(ctx context.Context, a, b tensor.Basic[DT], retVal DescWithStorage, asSameDT bool, expAPA, expAPB *tensor.AP) (err error) {
	op := lteOp[DT]()
	if asSameDT {
		var v DT
		return errors.Errorf("Unable to perform %v for data type %T", errors.ThisFn(), v)
	}
	return e.CmpOpBC(ctx, a, b, retVal.(tensor.Basic[bool]), expAPA, expAPB, op)
}

// Gt performs `a > b`, with a bool tensor as the return value. If`asSameDT == true`, an error will be returned.
func (e OrderedEng[DT, T]) Gt(ctx context.Context, a, b tensor.Basic[DT], retVal DescWithStorage, asSameDT bool) (err error) {
	op := gtOp[DT]()
	if asSameDT {
		var v DT
		return errors.Errorf("Unable to perform %v for data type %T", errors.ThisFn(), v)
	}
	return e.CmpOp(ctx, a, b, retVal.(tensor.Basic[bool]), op)
}

// GtScalar performs `vec > scalar` or `scalar > vec`, with a bool tensor as the return value. The `scalarOnLeft` parameter indicates
// if the scalar value is on the left of the bin op. If `asSameDT` == true, an error will be returned.
func (e OrderedEng[DT, T]) GtScalar(ctx context.Context, a tensor.Basic[DT], b DT, retVal DescWithStorage, scalarOnLeft bool, asSameDT bool) (err error) {
	op := gtOp[DT]()
	if asSameDT {
		var v DT
		return errors.Errorf("Unable to perform %v for data type %T", errors.ThisFn(), v)
	}
	return e.CmpOpScalar(ctx, a, b, retVal.(tensor.Basic[bool]), scalarOnLeft, op)
}

// GtBroadcastable performs `a > b`, with a bool tensor as the return value. The operation is broadacasted correctly according to shape. If`asSameDT == true`, an error will be returned.
func (e OrderedEng[DT, T]) GtBroadcastable(ctx context.Context, a, b tensor.Basic[DT], retVal DescWithStorage, asSameDT bool, expAPA, expAPB *tensor.AP) (err error) {
	op := gtOp[DT]()
	if asSameDT {
		var v DT
		return errors.Errorf("Unable to perform %v for data type %T", errors.ThisFn(), v)
	}
	return e.CmpOpBC(ctx, a, b, retVal.(tensor.Basic[bool]), expAPA, expAPB, op)
}

// Gte performs `a >= b`, with a bool tensor as the return value. If`asSameDT == true`, an error will be returned.
func (e OrderedEng[DT, T]) Gte(ctx context.Context, a, b tensor.Basic[DT], retVal DescWithStorage, asSameDT bool) (err error) {
	op := gteOp[DT]()
	if asSameDT {
		var v DT
		return errors.Errorf("Unable to perform %v for data type %T", errors.ThisFn(), v)
	}
	return e.CmpOp(ctx, a, b, retVal.(tensor.Basic[bool]), op)
}

// GteScalar performs `vec >= scalar` or `scalar >= vec`, with a bool tensor as the return value. The `scalarOnLeft` parameter indicates
// if the scalar value is on the left of the bin op. If `asSameDT` == true, an error will be returned.
func (e OrderedEng[DT, T]) GteScalar(ctx context.Context, a tensor.Basic[DT], b DT, retVal DescWithStorage, scalarOnLeft bool, asSameDT bool) (err error) {
	op := gteOp[DT]()
	if asSameDT {
		var v DT
		return errors.Errorf("Unable to perform %v for data type %T", errors.ThisFn(), v)
	}
	return e.CmpOpScalar(ctx, a, b, retVal.(tensor.Basic[bool]), scalarOnLeft, op)
}

// GteBroadcastable performs `a >= b`, with a bool tensor as the return value. The operation is broadacasted correctly according to shape. If`asSameDT == true`, an error will be returned.
func (e OrderedEng[DT, T]) GteBroadcastable(ctx context.Context, a, b tensor.Basic[DT], retVal DescWithStorage, asSameDT bool, expAPA, expAPB *tensor.AP) (err error) {
	op := gteOp[DT]()
	if asSameDT {
		var v DT
		return errors.Errorf("Unable to perform %v for data type %T", errors.ThisFn(), v)
	}
	return e.CmpOpBC(ctx, a, b, retVal.(tensor.Basic[bool]), expAPA, expAPB, op)
}
