// Code generated by genlib2. DO NOT EDIT.

package tensor

import (
	"reflect"
	"unsafe"

	"github.com/pkg/errors"
)

func checkNativeIterable(t *Dense, dims int, dt Dtype) error {
	// checks:
	if !t.IsNativelyAccessible() {
		return errors.Errorf("Cannot convert *Dense to *mat.Dense. Data is inaccessible")
	}

	if t.shape.Dims() != dims {
		return errors.Errorf("Cannot convert *Dense to native iterator. Expected number of dimension: %d, T has got %d dimensions (Shape: %v)", dims, t.Dims(), t.Shape())
	}

	if t.DataOrder().isColMajor() || t.RequiresIterator() {
		return errors.Errorf("Not yet implemented: native matrix for colmajor or unpacked matrices")
	}

	if t.Dtype() != dt {
		return errors.Errorf("Conversion to native iterable only works on %v. Got %v", dt, t.Dtype())
	}

	return nil
}

/* Native Iterables for bool */

// NativeVectorB converts a *Dense into a []bool
// If the *Dense does not represent a vector of the wanted type, it will return an error.
func NativeVectorB(t *Dense) (retVal []bool, err error) {
	if err = checkNativeIterable(t, 1, Bool); err != nil {
		return nil, err
	}
	return t.Data().([]bool), nil
}

// NativeMatrixB converts a  *Dense into a [][]bool
// If the *Dense does not represent a matrix of the wanted type, it will return an error.
func NativeMatrixB(t *Dense) (retVal [][]bool, err error) {
	if err = checkNativeIterable(t, 2, Bool); err != nil {
		return nil, err
	}

	data := t.Data().([]bool)
	shape := t.Shape()
	strides := t.Strides()

	rows := shape[0]
	cols := shape[1]
	rowStride := strides[0]
	retVal = make([][]bool, rows)
	for i := range retVal {
		start := i * rowStride
		hdr := &reflect.SliceHeader{
			Data: uintptr(unsafe.Pointer(&data[start])),
			Len:  cols,
			Cap:  cols,
		}
		retVal[i] = *(*[]bool)(unsafe.Pointer(hdr))
	}
	return
}

// Native3TensorB converts a *Dense into  a [][][]bool.
// If the *Dense does not represent a 3-tensor of the wanted type, it will return an error.
func Native3TensorB(t *Dense) (retVal [][][]bool, err error) {
	if err = checkNativeIterable(t, 3, Float64); err != nil {
		return nil, err
	}

	data := t.Data().([]bool)
	shape := t.Shape()
	strides := t.Strides()

	layers := shape[0]
	rows := shape[1]
	cols := shape[2]
	layerStride := strides[0]
	rowStride := strides[1]
	retVal = make([][][]bool, layers)
	for i := range retVal {
		retVal[i] = make([][]bool, rows)
		for j := range retVal[i] {
			start := i*layerStride + j*rowStride
			hdr := &reflect.SliceHeader{
				Data: uintptr(unsafe.Pointer(&data[start])),
				Len:  cols,
				Cap:  cols,
			}
			retVal[i][j] = *(*[]bool)(unsafe.Pointer(hdr))
		}
	}
	return
}

/* Native Iterables for int */

// NativeVectorI converts a *Dense into a []int
// If the *Dense does not represent a vector of the wanted type, it will return an error.
func NativeVectorI(t *Dense) (retVal []int, err error) {
	if err = checkNativeIterable(t, 1, Int); err != nil {
		return nil, err
	}
	return t.Data().([]int), nil
}

// NativeMatrixI converts a  *Dense into a [][]int
// If the *Dense does not represent a matrix of the wanted type, it will return an error.
func NativeMatrixI(t *Dense) (retVal [][]int, err error) {
	if err = checkNativeIterable(t, 2, Int); err != nil {
		return nil, err
	}

	data := t.Data().([]int)
	shape := t.Shape()
	strides := t.Strides()

	rows := shape[0]
	cols := shape[1]
	rowStride := strides[0]
	retVal = make([][]int, rows)
	for i := range retVal {
		start := i * rowStride
		hdr := &reflect.SliceHeader{
			Data: uintptr(unsafe.Pointer(&data[start])),
			Len:  cols,
			Cap:  cols,
		}
		retVal[i] = *(*[]int)(unsafe.Pointer(hdr))
	}
	return
}

// Native3TensorI converts a *Dense into  a [][][]int.
// If the *Dense does not represent a 3-tensor of the wanted type, it will return an error.
func Native3TensorI(t *Dense) (retVal [][][]int, err error) {
	if err = checkNativeIterable(t, 3, Float64); err != nil {
		return nil, err
	}

	data := t.Data().([]int)
	shape := t.Shape()
	strides := t.Strides()

	layers := shape[0]
	rows := shape[1]
	cols := shape[2]
	layerStride := strides[0]
	rowStride := strides[1]
	retVal = make([][][]int, layers)
	for i := range retVal {
		retVal[i] = make([][]int, rows)
		for j := range retVal[i] {
			start := i*layerStride + j*rowStride
			hdr := &reflect.SliceHeader{
				Data: uintptr(unsafe.Pointer(&data[start])),
				Len:  cols,
				Cap:  cols,
			}
			retVal[i][j] = *(*[]int)(unsafe.Pointer(hdr))
		}
	}
	return
}

/* Native Iterables for int8 */

// NativeVectorI8 converts a *Dense into a []int8
// If the *Dense does not represent a vector of the wanted type, it will return an error.
func NativeVectorI8(t *Dense) (retVal []int8, err error) {
	if err = checkNativeIterable(t, 1, Int8); err != nil {
		return nil, err
	}
	return t.Data().([]int8), nil
}

// NativeMatrixI8 converts a  *Dense into a [][]int8
// If the *Dense does not represent a matrix of the wanted type, it will return an error.
func NativeMatrixI8(t *Dense) (retVal [][]int8, err error) {
	if err = checkNativeIterable(t, 2, Int8); err != nil {
		return nil, err
	}

	data := t.Data().([]int8)
	shape := t.Shape()
	strides := t.Strides()

	rows := shape[0]
	cols := shape[1]
	rowStride := strides[0]
	retVal = make([][]int8, rows)
	for i := range retVal {
		start := i * rowStride
		hdr := &reflect.SliceHeader{
			Data: uintptr(unsafe.Pointer(&data[start])),
			Len:  cols,
			Cap:  cols,
		}
		retVal[i] = *(*[]int8)(unsafe.Pointer(hdr))
	}
	return
}

// Native3TensorI8 converts a *Dense into  a [][][]int8.
// If the *Dense does not represent a 3-tensor of the wanted type, it will return an error.
func Native3TensorI8(t *Dense) (retVal [][][]int8, err error) {
	if err = checkNativeIterable(t, 3, Float64); err != nil {
		return nil, err
	}

	data := t.Data().([]int8)
	shape := t.Shape()
	strides := t.Strides()

	layers := shape[0]
	rows := shape[1]
	cols := shape[2]
	layerStride := strides[0]
	rowStride := strides[1]
	retVal = make([][][]int8, layers)
	for i := range retVal {
		retVal[i] = make([][]int8, rows)
		for j := range retVal[i] {
			start := i*layerStride + j*rowStride
			hdr := &reflect.SliceHeader{
				Data: uintptr(unsafe.Pointer(&data[start])),
				Len:  cols,
				Cap:  cols,
			}
			retVal[i][j] = *(*[]int8)(unsafe.Pointer(hdr))
		}
	}
	return
}

/* Native Iterables for int16 */

// NativeVectorI16 converts a *Dense into a []int16
// If the *Dense does not represent a vector of the wanted type, it will return an error.
func NativeVectorI16(t *Dense) (retVal []int16, err error) {
	if err = checkNativeIterable(t, 1, Int16); err != nil {
		return nil, err
	}
	return t.Data().([]int16), nil
}

// NativeMatrixI16 converts a  *Dense into a [][]int16
// If the *Dense does not represent a matrix of the wanted type, it will return an error.
func NativeMatrixI16(t *Dense) (retVal [][]int16, err error) {
	if err = checkNativeIterable(t, 2, Int16); err != nil {
		return nil, err
	}

	data := t.Data().([]int16)
	shape := t.Shape()
	strides := t.Strides()

	rows := shape[0]
	cols := shape[1]
	rowStride := strides[0]
	retVal = make([][]int16, rows)
	for i := range retVal {
		start := i * rowStride
		hdr := &reflect.SliceHeader{
			Data: uintptr(unsafe.Pointer(&data[start])),
			Len:  cols,
			Cap:  cols,
		}
		retVal[i] = *(*[]int16)(unsafe.Pointer(hdr))
	}
	return
}

// Native3TensorI16 converts a *Dense into  a [][][]int16.
// If the *Dense does not represent a 3-tensor of the wanted type, it will return an error.
func Native3TensorI16(t *Dense) (retVal [][][]int16, err error) {
	if err = checkNativeIterable(t, 3, Float64); err != nil {
		return nil, err
	}

	data := t.Data().([]int16)
	shape := t.Shape()
	strides := t.Strides()

	layers := shape[0]
	rows := shape[1]
	cols := shape[2]
	layerStride := strides[0]
	rowStride := strides[1]
	retVal = make([][][]int16, layers)
	for i := range retVal {
		retVal[i] = make([][]int16, rows)
		for j := range retVal[i] {
			start := i*layerStride + j*rowStride
			hdr := &reflect.SliceHeader{
				Data: uintptr(unsafe.Pointer(&data[start])),
				Len:  cols,
				Cap:  cols,
			}
			retVal[i][j] = *(*[]int16)(unsafe.Pointer(hdr))
		}
	}
	return
}

/* Native Iterables for int32 */

// NativeVectorI32 converts a *Dense into a []int32
// If the *Dense does not represent a vector of the wanted type, it will return an error.
func NativeVectorI32(t *Dense) (retVal []int32, err error) {
	if err = checkNativeIterable(t, 1, Int32); err != nil {
		return nil, err
	}
	return t.Data().([]int32), nil
}

// NativeMatrixI32 converts a  *Dense into a [][]int32
// If the *Dense does not represent a matrix of the wanted type, it will return an error.
func NativeMatrixI32(t *Dense) (retVal [][]int32, err error) {
	if err = checkNativeIterable(t, 2, Int32); err != nil {
		return nil, err
	}

	data := t.Data().([]int32)
	shape := t.Shape()
	strides := t.Strides()

	rows := shape[0]
	cols := shape[1]
	rowStride := strides[0]
	retVal = make([][]int32, rows)
	for i := range retVal {
		start := i * rowStride
		hdr := &reflect.SliceHeader{
			Data: uintptr(unsafe.Pointer(&data[start])),
			Len:  cols,
			Cap:  cols,
		}
		retVal[i] = *(*[]int32)(unsafe.Pointer(hdr))
	}
	return
}

// Native3TensorI32 converts a *Dense into  a [][][]int32.
// If the *Dense does not represent a 3-tensor of the wanted type, it will return an error.
func Native3TensorI32(t *Dense) (retVal [][][]int32, err error) {
	if err = checkNativeIterable(t, 3, Float64); err != nil {
		return nil, err
	}

	data := t.Data().([]int32)
	shape := t.Shape()
	strides := t.Strides()

	layers := shape[0]
	rows := shape[1]
	cols := shape[2]
	layerStride := strides[0]
	rowStride := strides[1]
	retVal = make([][][]int32, layers)
	for i := range retVal {
		retVal[i] = make([][]int32, rows)
		for j := range retVal[i] {
			start := i*layerStride + j*rowStride
			hdr := &reflect.SliceHeader{
				Data: uintptr(unsafe.Pointer(&data[start])),
				Len:  cols,
				Cap:  cols,
			}
			retVal[i][j] = *(*[]int32)(unsafe.Pointer(hdr))
		}
	}
	return
}

/* Native Iterables for int64 */

// NativeVectorI64 converts a *Dense into a []int64
// If the *Dense does not represent a vector of the wanted type, it will return an error.
func NativeVectorI64(t *Dense) (retVal []int64, err error) {
	if err = checkNativeIterable(t, 1, Int64); err != nil {
		return nil, err
	}
	return t.Data().([]int64), nil
}

// NativeMatrixI64 converts a  *Dense into a [][]int64
// If the *Dense does not represent a matrix of the wanted type, it will return an error.
func NativeMatrixI64(t *Dense) (retVal [][]int64, err error) {
	if err = checkNativeIterable(t, 2, Int64); err != nil {
		return nil, err
	}

	data := t.Data().([]int64)
	shape := t.Shape()
	strides := t.Strides()

	rows := shape[0]
	cols := shape[1]
	rowStride := strides[0]
	retVal = make([][]int64, rows)
	for i := range retVal {
		start := i * rowStride
		hdr := &reflect.SliceHeader{
			Data: uintptr(unsafe.Pointer(&data[start])),
			Len:  cols,
			Cap:  cols,
		}
		retVal[i] = *(*[]int64)(unsafe.Pointer(hdr))
	}
	return
}

// Native3TensorI64 converts a *Dense into  a [][][]int64.
// If the *Dense does not represent a 3-tensor of the wanted type, it will return an error.
func Native3TensorI64(t *Dense) (retVal [][][]int64, err error) {
	if err = checkNativeIterable(t, 3, Float64); err != nil {
		return nil, err
	}

	data := t.Data().([]int64)
	shape := t.Shape()
	strides := t.Strides()

	layers := shape[0]
	rows := shape[1]
	cols := shape[2]
	layerStride := strides[0]
	rowStride := strides[1]
	retVal = make([][][]int64, layers)
	for i := range retVal {
		retVal[i] = make([][]int64, rows)
		for j := range retVal[i] {
			start := i*layerStride + j*rowStride
			hdr := &reflect.SliceHeader{
				Data: uintptr(unsafe.Pointer(&data[start])),
				Len:  cols,
				Cap:  cols,
			}
			retVal[i][j] = *(*[]int64)(unsafe.Pointer(hdr))
		}
	}
	return
}

/* Native Iterables for uint */

// NativeVectorU converts a *Dense into a []uint
// If the *Dense does not represent a vector of the wanted type, it will return an error.
func NativeVectorU(t *Dense) (retVal []uint, err error) {
	if err = checkNativeIterable(t, 1, Uint); err != nil {
		return nil, err
	}
	return t.Data().([]uint), nil
}

// NativeMatrixU converts a  *Dense into a [][]uint
// If the *Dense does not represent a matrix of the wanted type, it will return an error.
func NativeMatrixU(t *Dense) (retVal [][]uint, err error) {
	if err = checkNativeIterable(t, 2, Uint); err != nil {
		return nil, err
	}

	data := t.Data().([]uint)
	shape := t.Shape()
	strides := t.Strides()

	rows := shape[0]
	cols := shape[1]
	rowStride := strides[0]
	retVal = make([][]uint, rows)
	for i := range retVal {
		start := i * rowStride
		hdr := &reflect.SliceHeader{
			Data: uintptr(unsafe.Pointer(&data[start])),
			Len:  cols,
			Cap:  cols,
		}
		retVal[i] = *(*[]uint)(unsafe.Pointer(hdr))
	}
	return
}

// Native3TensorU converts a *Dense into  a [][][]uint.
// If the *Dense does not represent a 3-tensor of the wanted type, it will return an error.
func Native3TensorU(t *Dense) (retVal [][][]uint, err error) {
	if err = checkNativeIterable(t, 3, Float64); err != nil {
		return nil, err
	}

	data := t.Data().([]uint)
	shape := t.Shape()
	strides := t.Strides()

	layers := shape[0]
	rows := shape[1]
	cols := shape[2]
	layerStride := strides[0]
	rowStride := strides[1]
	retVal = make([][][]uint, layers)
	for i := range retVal {
		retVal[i] = make([][]uint, rows)
		for j := range retVal[i] {
			start := i*layerStride + j*rowStride
			hdr := &reflect.SliceHeader{
				Data: uintptr(unsafe.Pointer(&data[start])),
				Len:  cols,
				Cap:  cols,
			}
			retVal[i][j] = *(*[]uint)(unsafe.Pointer(hdr))
		}
	}
	return
}

/* Native Iterables for uint8 */

// NativeVectorU8 converts a *Dense into a []uint8
// If the *Dense does not represent a vector of the wanted type, it will return an error.
func NativeVectorU8(t *Dense) (retVal []uint8, err error) {
	if err = checkNativeIterable(t, 1, Uint8); err != nil {
		return nil, err
	}
	return t.Data().([]uint8), nil
}

// NativeMatrixU8 converts a  *Dense into a [][]uint8
// If the *Dense does not represent a matrix of the wanted type, it will return an error.
func NativeMatrixU8(t *Dense) (retVal [][]uint8, err error) {
	if err = checkNativeIterable(t, 2, Uint8); err != nil {
		return nil, err
	}

	data := t.Data().([]uint8)
	shape := t.Shape()
	strides := t.Strides()

	rows := shape[0]
	cols := shape[1]
	rowStride := strides[0]
	retVal = make([][]uint8, rows)
	for i := range retVal {
		start := i * rowStride
		hdr := &reflect.SliceHeader{
			Data: uintptr(unsafe.Pointer(&data[start])),
			Len:  cols,
			Cap:  cols,
		}
		retVal[i] = *(*[]uint8)(unsafe.Pointer(hdr))
	}
	return
}

// Native3TensorU8 converts a *Dense into  a [][][]uint8.
// If the *Dense does not represent a 3-tensor of the wanted type, it will return an error.
func Native3TensorU8(t *Dense) (retVal [][][]uint8, err error) {
	if err = checkNativeIterable(t, 3, Float64); err != nil {
		return nil, err
	}

	data := t.Data().([]uint8)
	shape := t.Shape()
	strides := t.Strides()

	layers := shape[0]
	rows := shape[1]
	cols := shape[2]
	layerStride := strides[0]
	rowStride := strides[1]
	retVal = make([][][]uint8, layers)
	for i := range retVal {
		retVal[i] = make([][]uint8, rows)
		for j := range retVal[i] {
			start := i*layerStride + j*rowStride
			hdr := &reflect.SliceHeader{
				Data: uintptr(unsafe.Pointer(&data[start])),
				Len:  cols,
				Cap:  cols,
			}
			retVal[i][j] = *(*[]uint8)(unsafe.Pointer(hdr))
		}
	}
	return
}

/* Native Iterables for uint16 */

// NativeVectorU16 converts a *Dense into a []uint16
// If the *Dense does not represent a vector of the wanted type, it will return an error.
func NativeVectorU16(t *Dense) (retVal []uint16, err error) {
	if err = checkNativeIterable(t, 1, Uint16); err != nil {
		return nil, err
	}
	return t.Data().([]uint16), nil
}

// NativeMatrixU16 converts a  *Dense into a [][]uint16
// If the *Dense does not represent a matrix of the wanted type, it will return an error.
func NativeMatrixU16(t *Dense) (retVal [][]uint16, err error) {
	if err = checkNativeIterable(t, 2, Uint16); err != nil {
		return nil, err
	}

	data := t.Data().([]uint16)
	shape := t.Shape()
	strides := t.Strides()

	rows := shape[0]
	cols := shape[1]
	rowStride := strides[0]
	retVal = make([][]uint16, rows)
	for i := range retVal {
		start := i * rowStride
		hdr := &reflect.SliceHeader{
			Data: uintptr(unsafe.Pointer(&data[start])),
			Len:  cols,
			Cap:  cols,
		}
		retVal[i] = *(*[]uint16)(unsafe.Pointer(hdr))
	}
	return
}

// Native3TensorU16 converts a *Dense into  a [][][]uint16.
// If the *Dense does not represent a 3-tensor of the wanted type, it will return an error.
func Native3TensorU16(t *Dense) (retVal [][][]uint16, err error) {
	if err = checkNativeIterable(t, 3, Float64); err != nil {
		return nil, err
	}

	data := t.Data().([]uint16)
	shape := t.Shape()
	strides := t.Strides()

	layers := shape[0]
	rows := shape[1]
	cols := shape[2]
	layerStride := strides[0]
	rowStride := strides[1]
	retVal = make([][][]uint16, layers)
	for i := range retVal {
		retVal[i] = make([][]uint16, rows)
		for j := range retVal[i] {
			start := i*layerStride + j*rowStride
			hdr := &reflect.SliceHeader{
				Data: uintptr(unsafe.Pointer(&data[start])),
				Len:  cols,
				Cap:  cols,
			}
			retVal[i][j] = *(*[]uint16)(unsafe.Pointer(hdr))
		}
	}
	return
}

/* Native Iterables for uint32 */

// NativeVectorU32 converts a *Dense into a []uint32
// If the *Dense does not represent a vector of the wanted type, it will return an error.
func NativeVectorU32(t *Dense) (retVal []uint32, err error) {
	if err = checkNativeIterable(t, 1, Uint32); err != nil {
		return nil, err
	}
	return t.Data().([]uint32), nil
}

// NativeMatrixU32 converts a  *Dense into a [][]uint32
// If the *Dense does not represent a matrix of the wanted type, it will return an error.
func NativeMatrixU32(t *Dense) (retVal [][]uint32, err error) {
	if err = checkNativeIterable(t, 2, Uint32); err != nil {
		return nil, err
	}

	data := t.Data().([]uint32)
	shape := t.Shape()
	strides := t.Strides()

	rows := shape[0]
	cols := shape[1]
	rowStride := strides[0]
	retVal = make([][]uint32, rows)
	for i := range retVal {
		start := i * rowStride
		hdr := &reflect.SliceHeader{
			Data: uintptr(unsafe.Pointer(&data[start])),
			Len:  cols,
			Cap:  cols,
		}
		retVal[i] = *(*[]uint32)(unsafe.Pointer(hdr))
	}
	return
}

// Native3TensorU32 converts a *Dense into  a [][][]uint32.
// If the *Dense does not represent a 3-tensor of the wanted type, it will return an error.
func Native3TensorU32(t *Dense) (retVal [][][]uint32, err error) {
	if err = checkNativeIterable(t, 3, Float64); err != nil {
		return nil, err
	}

	data := t.Data().([]uint32)
	shape := t.Shape()
	strides := t.Strides()

	layers := shape[0]
	rows := shape[1]
	cols := shape[2]
	layerStride := strides[0]
	rowStride := strides[1]
	retVal = make([][][]uint32, layers)
	for i := range retVal {
		retVal[i] = make([][]uint32, rows)
		for j := range retVal[i] {
			start := i*layerStride + j*rowStride
			hdr := &reflect.SliceHeader{
				Data: uintptr(unsafe.Pointer(&data[start])),
				Len:  cols,
				Cap:  cols,
			}
			retVal[i][j] = *(*[]uint32)(unsafe.Pointer(hdr))
		}
	}
	return
}

/* Native Iterables for uint64 */

// NativeVectorU64 converts a *Dense into a []uint64
// If the *Dense does not represent a vector of the wanted type, it will return an error.
func NativeVectorU64(t *Dense) (retVal []uint64, err error) {
	if err = checkNativeIterable(t, 1, Uint64); err != nil {
		return nil, err
	}
	return t.Data().([]uint64), nil
}

// NativeMatrixU64 converts a  *Dense into a [][]uint64
// If the *Dense does not represent a matrix of the wanted type, it will return an error.
func NativeMatrixU64(t *Dense) (retVal [][]uint64, err error) {
	if err = checkNativeIterable(t, 2, Uint64); err != nil {
		return nil, err
	}

	data := t.Data().([]uint64)
	shape := t.Shape()
	strides := t.Strides()

	rows := shape[0]
	cols := shape[1]
	rowStride := strides[0]
	retVal = make([][]uint64, rows)
	for i := range retVal {
		start := i * rowStride
		hdr := &reflect.SliceHeader{
			Data: uintptr(unsafe.Pointer(&data[start])),
			Len:  cols,
			Cap:  cols,
		}
		retVal[i] = *(*[]uint64)(unsafe.Pointer(hdr))
	}
	return
}

// Native3TensorU64 converts a *Dense into  a [][][]uint64.
// If the *Dense does not represent a 3-tensor of the wanted type, it will return an error.
func Native3TensorU64(t *Dense) (retVal [][][]uint64, err error) {
	if err = checkNativeIterable(t, 3, Float64); err != nil {
		return nil, err
	}

	data := t.Data().([]uint64)
	shape := t.Shape()
	strides := t.Strides()

	layers := shape[0]
	rows := shape[1]
	cols := shape[2]
	layerStride := strides[0]
	rowStride := strides[1]
	retVal = make([][][]uint64, layers)
	for i := range retVal {
		retVal[i] = make([][]uint64, rows)
		for j := range retVal[i] {
			start := i*layerStride + j*rowStride
			hdr := &reflect.SliceHeader{
				Data: uintptr(unsafe.Pointer(&data[start])),
				Len:  cols,
				Cap:  cols,
			}
			retVal[i][j] = *(*[]uint64)(unsafe.Pointer(hdr))
		}
	}
	return
}

/* Native Iterables for float32 */

// NativeVectorF32 converts a *Dense into a []float32
// If the *Dense does not represent a vector of the wanted type, it will return an error.
func NativeVectorF32(t *Dense) (retVal []float32, err error) {
	if err = checkNativeIterable(t, 1, Float32); err != nil {
		return nil, err
	}
	return t.Data().([]float32), nil
}

// NativeMatrixF32 converts a  *Dense into a [][]float32
// If the *Dense does not represent a matrix of the wanted type, it will return an error.
func NativeMatrixF32(t *Dense) (retVal [][]float32, err error) {
	if err = checkNativeIterable(t, 2, Float32); err != nil {
		return nil, err
	}

	data := t.Data().([]float32)
	shape := t.Shape()
	strides := t.Strides()

	rows := shape[0]
	cols := shape[1]
	rowStride := strides[0]
	retVal = make([][]float32, rows)
	for i := range retVal {
		start := i * rowStride
		hdr := &reflect.SliceHeader{
			Data: uintptr(unsafe.Pointer(&data[start])),
			Len:  cols,
			Cap:  cols,
		}
		retVal[i] = *(*[]float32)(unsafe.Pointer(hdr))
	}
	return
}

// Native3TensorF32 converts a *Dense into  a [][][]float32.
// If the *Dense does not represent a 3-tensor of the wanted type, it will return an error.
func Native3TensorF32(t *Dense) (retVal [][][]float32, err error) {
	if err = checkNativeIterable(t, 3, Float64); err != nil {
		return nil, err
	}

	data := t.Data().([]float32)
	shape := t.Shape()
	strides := t.Strides()

	layers := shape[0]
	rows := shape[1]
	cols := shape[2]
	layerStride := strides[0]
	rowStride := strides[1]
	retVal = make([][][]float32, layers)
	for i := range retVal {
		retVal[i] = make([][]float32, rows)
		for j := range retVal[i] {
			start := i*layerStride + j*rowStride
			hdr := &reflect.SliceHeader{
				Data: uintptr(unsafe.Pointer(&data[start])),
				Len:  cols,
				Cap:  cols,
			}
			retVal[i][j] = *(*[]float32)(unsafe.Pointer(hdr))
		}
	}
	return
}

/* Native Iterables for float64 */

// NativeVectorF64 converts a *Dense into a []float64
// If the *Dense does not represent a vector of the wanted type, it will return an error.
func NativeVectorF64(t *Dense) (retVal []float64, err error) {
	if err = checkNativeIterable(t, 1, Float64); err != nil {
		return nil, err
	}
	return t.Data().([]float64), nil
}

// NativeMatrixF64 converts a  *Dense into a [][]float64
// If the *Dense does not represent a matrix of the wanted type, it will return an error.
func NativeMatrixF64(t *Dense) (retVal [][]float64, err error) {
	if err = checkNativeIterable(t, 2, Float64); err != nil {
		return nil, err
	}

	data := t.Data().([]float64)
	shape := t.Shape()
	strides := t.Strides()

	rows := shape[0]
	cols := shape[1]
	rowStride := strides[0]
	retVal = make([][]float64, rows)
	for i := range retVal {
		start := i * rowStride
		hdr := &reflect.SliceHeader{
			Data: uintptr(unsafe.Pointer(&data[start])),
			Len:  cols,
			Cap:  cols,
		}
		retVal[i] = *(*[]float64)(unsafe.Pointer(hdr))
	}
	return
}

// Native3TensorF64 converts a *Dense into  a [][][]float64.
// If the *Dense does not represent a 3-tensor of the wanted type, it will return an error.
func Native3TensorF64(t *Dense) (retVal [][][]float64, err error) {
	if err = checkNativeIterable(t, 3, Float64); err != nil {
		return nil, err
	}

	data := t.Data().([]float64)
	shape := t.Shape()
	strides := t.Strides()

	layers := shape[0]
	rows := shape[1]
	cols := shape[2]
	layerStride := strides[0]
	rowStride := strides[1]
	retVal = make([][][]float64, layers)
	for i := range retVal {
		retVal[i] = make([][]float64, rows)
		for j := range retVal[i] {
			start := i*layerStride + j*rowStride
			hdr := &reflect.SliceHeader{
				Data: uintptr(unsafe.Pointer(&data[start])),
				Len:  cols,
				Cap:  cols,
			}
			retVal[i][j] = *(*[]float64)(unsafe.Pointer(hdr))
		}
	}
	return
}

/* Native Iterables for complex64 */

// NativeVectorC64 converts a *Dense into a []complex64
// If the *Dense does not represent a vector of the wanted type, it will return an error.
func NativeVectorC64(t *Dense) (retVal []complex64, err error) {
	if err = checkNativeIterable(t, 1, Complex64); err != nil {
		return nil, err
	}
	return t.Data().([]complex64), nil
}

// NativeMatrixC64 converts a  *Dense into a [][]complex64
// If the *Dense does not represent a matrix of the wanted type, it will return an error.
func NativeMatrixC64(t *Dense) (retVal [][]complex64, err error) {
	if err = checkNativeIterable(t, 2, Complex64); err != nil {
		return nil, err
	}

	data := t.Data().([]complex64)
	shape := t.Shape()
	strides := t.Strides()

	rows := shape[0]
	cols := shape[1]
	rowStride := strides[0]
	retVal = make([][]complex64, rows)
	for i := range retVal {
		start := i * rowStride
		hdr := &reflect.SliceHeader{
			Data: uintptr(unsafe.Pointer(&data[start])),
			Len:  cols,
			Cap:  cols,
		}
		retVal[i] = *(*[]complex64)(unsafe.Pointer(hdr))
	}
	return
}

// Native3TensorC64 converts a *Dense into  a [][][]complex64.
// If the *Dense does not represent a 3-tensor of the wanted type, it will return an error.
func Native3TensorC64(t *Dense) (retVal [][][]complex64, err error) {
	if err = checkNativeIterable(t, 3, Float64); err != nil {
		return nil, err
	}

	data := t.Data().([]complex64)
	shape := t.Shape()
	strides := t.Strides()

	layers := shape[0]
	rows := shape[1]
	cols := shape[2]
	layerStride := strides[0]
	rowStride := strides[1]
	retVal = make([][][]complex64, layers)
	for i := range retVal {
		retVal[i] = make([][]complex64, rows)
		for j := range retVal[i] {
			start := i*layerStride + j*rowStride
			hdr := &reflect.SliceHeader{
				Data: uintptr(unsafe.Pointer(&data[start])),
				Len:  cols,
				Cap:  cols,
			}
			retVal[i][j] = *(*[]complex64)(unsafe.Pointer(hdr))
		}
	}
	return
}

/* Native Iterables for complex128 */

// NativeVectorC128 converts a *Dense into a []complex128
// If the *Dense does not represent a vector of the wanted type, it will return an error.
func NativeVectorC128(t *Dense) (retVal []complex128, err error) {
	if err = checkNativeIterable(t, 1, Complex128); err != nil {
		return nil, err
	}
	return t.Data().([]complex128), nil
}

// NativeMatrixC128 converts a  *Dense into a [][]complex128
// If the *Dense does not represent a matrix of the wanted type, it will return an error.
func NativeMatrixC128(t *Dense) (retVal [][]complex128, err error) {
	if err = checkNativeIterable(t, 2, Complex128); err != nil {
		return nil, err
	}

	data := t.Data().([]complex128)
	shape := t.Shape()
	strides := t.Strides()

	rows := shape[0]
	cols := shape[1]
	rowStride := strides[0]
	retVal = make([][]complex128, rows)
	for i := range retVal {
		start := i * rowStride
		hdr := &reflect.SliceHeader{
			Data: uintptr(unsafe.Pointer(&data[start])),
			Len:  cols,
			Cap:  cols,
		}
		retVal[i] = *(*[]complex128)(unsafe.Pointer(hdr))
	}
	return
}

// Native3TensorC128 converts a *Dense into  a [][][]complex128.
// If the *Dense does not represent a 3-tensor of the wanted type, it will return an error.
func Native3TensorC128(t *Dense) (retVal [][][]complex128, err error) {
	if err = checkNativeIterable(t, 3, Float64); err != nil {
		return nil, err
	}

	data := t.Data().([]complex128)
	shape := t.Shape()
	strides := t.Strides()

	layers := shape[0]
	rows := shape[1]
	cols := shape[2]
	layerStride := strides[0]
	rowStride := strides[1]
	retVal = make([][][]complex128, layers)
	for i := range retVal {
		retVal[i] = make([][]complex128, rows)
		for j := range retVal[i] {
			start := i*layerStride + j*rowStride
			hdr := &reflect.SliceHeader{
				Data: uintptr(unsafe.Pointer(&data[start])),
				Len:  cols,
				Cap:  cols,
			}
			retVal[i][j] = *(*[]complex128)(unsafe.Pointer(hdr))
		}
	}
	return
}

/* Native Iterables for string */

// NativeVectorStr converts a *Dense into a []string
// If the *Dense does not represent a vector of the wanted type, it will return an error.
func NativeVectorStr(t *Dense) (retVal []string, err error) {
	if err = checkNativeIterable(t, 1, String); err != nil {
		return nil, err
	}
	return t.Data().([]string), nil
}

// NativeMatrixStr converts a  *Dense into a [][]string
// If the *Dense does not represent a matrix of the wanted type, it will return an error.
func NativeMatrixStr(t *Dense) (retVal [][]string, err error) {
	if err = checkNativeIterable(t, 2, String); err != nil {
		return nil, err
	}

	data := t.Data().([]string)
	shape := t.Shape()
	strides := t.Strides()

	rows := shape[0]
	cols := shape[1]
	rowStride := strides[0]
	retVal = make([][]string, rows)
	for i := range retVal {
		start := i * rowStride
		hdr := &reflect.SliceHeader{
			Data: uintptr(unsafe.Pointer(&data[start])),
			Len:  cols,
			Cap:  cols,
		}
		retVal[i] = *(*[]string)(unsafe.Pointer(hdr))
	}
	return
}

// Native3TensorStr converts a *Dense into  a [][][]string.
// If the *Dense does not represent a 3-tensor of the wanted type, it will return an error.
func Native3TensorStr(t *Dense) (retVal [][][]string, err error) {
	if err = checkNativeIterable(t, 3, Float64); err != nil {
		return nil, err
	}

	data := t.Data().([]string)
	shape := t.Shape()
	strides := t.Strides()

	layers := shape[0]
	rows := shape[1]
	cols := shape[2]
	layerStride := strides[0]
	rowStride := strides[1]
	retVal = make([][][]string, layers)
	for i := range retVal {
		retVal[i] = make([][]string, rows)
		for j := range retVal[i] {
			start := i*layerStride + j*rowStride
			hdr := &reflect.SliceHeader{
				Data: uintptr(unsafe.Pointer(&data[start])),
				Len:  cols,
				Cap:  cols,
			}
			retVal[i][j] = *(*[]string)(unsafe.Pointer(hdr))
		}
	}
	return
}
