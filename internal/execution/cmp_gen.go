// Code generated by genlib3. DO NOT EDIT

package execution

import (
	"gorgonia.org/tensor/internal"
	"gorgonia.org/tensor/internal/errors"
	"golang.org/x/exp/constraints"
)

// LtVV performs c := a ̅< b where c is of the same type as the inputs.
func LtVV[T OrderedNum](a, b, c []T) {
	a = a[:]
	b = b[:len(a)]
	c = c[:len(a)]

	for i := range a {
		if a[i] < b[i] {
			c[i] = T(1)
		} else {
			c[i] = T(0)
		}
	}
}

// LtVVIter performs c := a  ̅< b, where a, b, and c requires the use of an iterator.
func LtVVIter[T OrderedNum](a, b, c []T, ait, bit, cit Iterator) (err error) {
	var i, j, k int
	var validi, validj, validk bool
	var cisa, cisb bool
	if cisa, cisb, err = iterCheck3(a, b, c, ait, bit, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = ait.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if j, validj, err = bit.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}

		switch {
		case cisa:
			validk = validi
			k = i
		case cisb:
			validk = validj
			k = j
		default:
			if k, validk, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj && validk {
			if a[i] < b[j] {
				c[k] = T(1)
			} else {
				c[k] = T(0)
			}
		}
	}
	return
}

// LtVS performs c := vec ̅< scalar where c is of the same datatype as its inputs. The scalar value is broadcasted for the operation.
func LtVS[T OrderedNum](a []T, b T, c []T) {
	a = a[:]
	c = c[:len(a)]

	for i := range a {
		if a[i] < b {
			c[i] = T(1)
		} else {
			c[i] = T(0)
		}
	}
}

// LtVSIter performs c := vec ̅< scalar where c is of the same datatype as the inputs. The scalar value is broadcasted for the operation.
func LtVSIter[T OrderedNum](a []T, b T, c []T, ait, cit Iterator) (err error) {
	var i, j int
	var validi, validj bool
	var retIsVec bool
	if retIsVec, err = iterCheck2(a, c, ait, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = ait.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if retIsVec {
			j = i
			validj = validi
		} else {
			if j, validj, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj {
			if a[i] < b {
				c[j] = T(1)
			} else {
				c[j] = T(0)
			}
		}
	}
	return

}

// LtSV performs c := scalar ̅< vec where c is of the same datatype as the inputs. The scalar value is broadcasted for the operation.
func LtSV[T OrderedNum](a T, b []T, c []T) {
	b = b[:]
	c = c[:len(b)]

	for i := range b {
		if a < b[i] {
			c[i] = T(1)
		} else {
			c[i] = T(0)
		}
	}
}

// LtSVIter performs c := scalar ̅< vec where c is of the same datatype as the inputs. The scalar value is broadcasted for the operation.
func LtSVIter[T OrderedNum](a T, b []T, C []T, bit, cit Iterator) (err error) {
	var i, j int
	var validi, validj bool
	var retIsVec bool
	if retIsVec, err = iterCheck2(b, C, bit, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = bit.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if retIsVec {
			j = i
			validj = validi
		} else {
			if j, validj, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj {
			if a < b[i] {
				C[j] = T(1)
			} else {
				C[j] = T(0)
			}
		}
	}
	return

}

// LteVV performs c := a ̅<= b where c is of the same type as the inputs.
func LteVV[T OrderedNum](a, b, c []T) {
	a = a[:]
	b = b[:len(a)]
	c = c[:len(a)]

	for i := range a {
		if a[i] <= b[i] {
			c[i] = T(1)
		} else {
			c[i] = T(0)
		}
	}
}

// LteVVIter performs c := a  ̅<= b, where a, b, and c requires the use of an iterator.
func LteVVIter[T OrderedNum](a, b, c []T, ait, bit, cit Iterator) (err error) {
	var i, j, k int
	var validi, validj, validk bool
	var cisa, cisb bool
	if cisa, cisb, err = iterCheck3(a, b, c, ait, bit, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = ait.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if j, validj, err = bit.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}

		switch {
		case cisa:
			validk = validi
			k = i
		case cisb:
			validk = validj
			k = j
		default:
			if k, validk, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj && validk {
			if a[i] <= b[j] {
				c[k] = T(1)
			} else {
				c[k] = T(0)
			}
		}
	}
	return
}

// LteVS performs c := vec ̅<= scalar where c is of the same datatype as its inputs. The scalar value is broadcasted for the operation.
func LteVS[T OrderedNum](a []T, b T, c []T) {
	a = a[:]
	c = c[:len(a)]

	for i := range a {
		if a[i] <= b {
			c[i] = T(1)
		} else {
			c[i] = T(0)
		}
	}
}

// LteVSIter performs c := vec ̅<= scalar where c is of the same datatype as the inputs. The scalar value is broadcasted for the operation.
func LteVSIter[T OrderedNum](a []T, b T, c []T, ait, cit Iterator) (err error) {
	var i, j int
	var validi, validj bool
	var retIsVec bool
	if retIsVec, err = iterCheck2(a, c, ait, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = ait.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if retIsVec {
			j = i
			validj = validi
		} else {
			if j, validj, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj {
			if a[i] <= b {
				c[j] = T(1)
			} else {
				c[j] = T(0)
			}
		}
	}
	return

}

// LteSV performs c := scalar ̅<= vec where c is of the same datatype as the inputs. The scalar value is broadcasted for the operation.
func LteSV[T OrderedNum](a T, b []T, c []T) {
	b = b[:]
	c = c[:len(b)]

	for i := range b {
		if a <= b[i] {
			c[i] = T(1)
		} else {
			c[i] = T(0)
		}
	}
}

// LteSVIter performs c := scalar ̅<= vec where c is of the same datatype as the inputs. The scalar value is broadcasted for the operation.
func LteSVIter[T OrderedNum](a T, b []T, C []T, bit, cit Iterator) (err error) {
	var i, j int
	var validi, validj bool
	var retIsVec bool
	if retIsVec, err = iterCheck2(b, C, bit, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = bit.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if retIsVec {
			j = i
			validj = validi
		} else {
			if j, validj, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj {
			if a <= b[i] {
				C[j] = T(1)
			} else {
				C[j] = T(0)
			}
		}
	}
	return

}

// GtVV performs c := a ̅> b where c is of the same type as the inputs.
func GtVV[T OrderedNum](a, b, c []T) {
	a = a[:]
	b = b[:len(a)]
	c = c[:len(a)]

	for i := range a {
		if a[i] > b[i] {
			c[i] = T(1)
		} else {
			c[i] = T(0)
		}
	}
}

// GtVVIter performs c := a  ̅> b, where a, b, and c requires the use of an iterator.
func GtVVIter[T OrderedNum](a, b, c []T, ait, bit, cit Iterator) (err error) {
	var i, j, k int
	var validi, validj, validk bool
	var cisa, cisb bool
	if cisa, cisb, err = iterCheck3(a, b, c, ait, bit, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = ait.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if j, validj, err = bit.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}

		switch {
		case cisa:
			validk = validi
			k = i
		case cisb:
			validk = validj
			k = j
		default:
			if k, validk, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj && validk {
			if a[i] > b[j] {
				c[k] = T(1)
			} else {
				c[k] = T(0)
			}
		}
	}
	return
}

// GtVS performs c := vec ̅> scalar where c is of the same datatype as its inputs. The scalar value is broadcasted for the operation.
func GtVS[T OrderedNum](a []T, b T, c []T) {
	a = a[:]
	c = c[:len(a)]

	for i := range a {
		if a[i] > b {
			c[i] = T(1)
		} else {
			c[i] = T(0)
		}
	}
}

// GtVSIter performs c := vec ̅> scalar where c is of the same datatype as the inputs. The scalar value is broadcasted for the operation.
func GtVSIter[T OrderedNum](a []T, b T, c []T, ait, cit Iterator) (err error) {
	var i, j int
	var validi, validj bool
	var retIsVec bool
	if retIsVec, err = iterCheck2(a, c, ait, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = ait.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if retIsVec {
			j = i
			validj = validi
		} else {
			if j, validj, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj {
			if a[i] > b {
				c[j] = T(1)
			} else {
				c[j] = T(0)
			}
		}
	}
	return

}

// GtSV performs c := scalar ̅> vec where c is of the same datatype as the inputs. The scalar value is broadcasted for the operation.
func GtSV[T OrderedNum](a T, b []T, c []T) {
	b = b[:]
	c = c[:len(b)]

	for i := range b {
		if a > b[i] {
			c[i] = T(1)
		} else {
			c[i] = T(0)
		}
	}
}

// GtSVIter performs c := scalar ̅> vec where c is of the same datatype as the inputs. The scalar value is broadcasted for the operation.
func GtSVIter[T OrderedNum](a T, b []T, C []T, bit, cit Iterator) (err error) {
	var i, j int
	var validi, validj bool
	var retIsVec bool
	if retIsVec, err = iterCheck2(b, C, bit, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = bit.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if retIsVec {
			j = i
			validj = validi
		} else {
			if j, validj, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj {
			if a > b[i] {
				C[j] = T(1)
			} else {
				C[j] = T(0)
			}
		}
	}
	return

}

// GteVV performs c := a ̅>= b where c is of the same type as the inputs.
func GteVV[T OrderedNum](a, b, c []T) {
	a = a[:]
	b = b[:len(a)]
	c = c[:len(a)]

	for i := range a {
		if a[i] >= b[i] {
			c[i] = T(1)
		} else {
			c[i] = T(0)
		}
	}
}

// GteVVIter performs c := a  ̅>= b, where a, b, and c requires the use of an iterator.
func GteVVIter[T OrderedNum](a, b, c []T, ait, bit, cit Iterator) (err error) {
	var i, j, k int
	var validi, validj, validk bool
	var cisa, cisb bool
	if cisa, cisb, err = iterCheck3(a, b, c, ait, bit, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = ait.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if j, validj, err = bit.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}

		switch {
		case cisa:
			validk = validi
			k = i
		case cisb:
			validk = validj
			k = j
		default:
			if k, validk, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj && validk {
			if a[i] >= b[j] {
				c[k] = T(1)
			} else {
				c[k] = T(0)
			}
		}
	}
	return
}

// GteVS performs c := vec ̅>= scalar where c is of the same datatype as its inputs. The scalar value is broadcasted for the operation.
func GteVS[T OrderedNum](a []T, b T, c []T) {
	a = a[:]
	c = c[:len(a)]

	for i := range a {
		if a[i] >= b {
			c[i] = T(1)
		} else {
			c[i] = T(0)
		}
	}
}

// GteVSIter performs c := vec ̅>= scalar where c is of the same datatype as the inputs. The scalar value is broadcasted for the operation.
func GteVSIter[T OrderedNum](a []T, b T, c []T, ait, cit Iterator) (err error) {
	var i, j int
	var validi, validj bool
	var retIsVec bool
	if retIsVec, err = iterCheck2(a, c, ait, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = ait.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if retIsVec {
			j = i
			validj = validi
		} else {
			if j, validj, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj {
			if a[i] >= b {
				c[j] = T(1)
			} else {
				c[j] = T(0)
			}
		}
	}
	return

}

// GteSV performs c := scalar ̅>= vec where c is of the same datatype as the inputs. The scalar value is broadcasted for the operation.
func GteSV[T OrderedNum](a T, b []T, c []T) {
	b = b[:]
	c = c[:len(b)]

	for i := range b {
		if a >= b[i] {
			c[i] = T(1)
		} else {
			c[i] = T(0)
		}
	}
}

// GteSVIter performs c := scalar ̅>= vec where c is of the same datatype as the inputs. The scalar value is broadcasted for the operation.
func GteSVIter[T OrderedNum](a T, b []T, C []T, bit, cit Iterator) (err error) {
	var i, j int
	var validi, validj bool
	var retIsVec bool
	if retIsVec, err = iterCheck2(b, C, bit, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = bit.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if retIsVec {
			j = i
			validj = validi
		} else {
			if j, validj, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj {
			if a >= b[i] {
				C[j] = T(1)
			} else {
				C[j] = T(0)
			}
		}
	}
	return

}

// ElEqVV performs c := a ̅== b where c is of the same type as the inputs.
func ElEqVV[T Num](a, b, c []T) {
	a = a[:]
	b = b[:len(a)]
	c = c[:len(a)]

	for i := range a {
		if a[i] == b[i] {
			c[i] = T(1)
		} else {
			c[i] = T(0)
		}
	}
}

// ElEqVVIter performs c := a  ̅== b, where a, b, and c requires the use of an iterator.
func ElEqVVIter[T Num](a, b, c []T, ait, bit, cit Iterator) (err error) {
	var i, j, k int
	var validi, validj, validk bool
	var cisa, cisb bool
	if cisa, cisb, err = iterCheck3(a, b, c, ait, bit, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = ait.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if j, validj, err = bit.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}

		switch {
		case cisa:
			validk = validi
			k = i
		case cisb:
			validk = validj
			k = j
		default:
			if k, validk, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj && validk {
			if a[i] == b[j] {
				c[k] = T(1)
			} else {
				c[k] = T(0)
			}
		}
	}
	return
}

// ElEqVS performs c := vec ̅== scalar where c is of the same datatype as its inputs. The scalar value is broadcasted for the operation.
func ElEqVS[T Num](a []T, b T, c []T) {
	a = a[:]
	c = c[:len(a)]

	for i := range a {
		if a[i] == b {
			c[i] = T(1)
		} else {
			c[i] = T(0)
		}
	}
}

// ElEqVSIter performs c := vec ̅== scalar where c is of the same datatype as the inputs. The scalar value is broadcasted for the operation.
func ElEqVSIter[T Num](a []T, b T, c []T, ait, cit Iterator) (err error) {
	var i, j int
	var validi, validj bool
	var retIsVec bool
	if retIsVec, err = iterCheck2(a, c, ait, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = ait.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if retIsVec {
			j = i
			validj = validi
		} else {
			if j, validj, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj {
			if a[i] == b {
				c[j] = T(1)
			} else {
				c[j] = T(0)
			}
		}
	}
	return

}

// ElEqSV performs c := scalar ̅== vec where c is of the same datatype as the inputs. The scalar value is broadcasted for the operation.
func ElEqSV[T Num](a T, b []T, c []T) {
	b = b[:]
	c = c[:len(b)]

	for i := range b {
		if a == b[i] {
			c[i] = T(1)
		} else {
			c[i] = T(0)
		}
	}
}

// ElEqSVIter performs c := scalar ̅== vec where c is of the same datatype as the inputs. The scalar value is broadcasted for the operation.
func ElEqSVIter[T Num](a T, b []T, C []T, bit, cit Iterator) (err error) {
	var i, j int
	var validi, validj bool
	var retIsVec bool
	if retIsVec, err = iterCheck2(b, C, bit, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = bit.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if retIsVec {
			j = i
			validj = validi
		} else {
			if j, validj, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj {
			if a == b[i] {
				C[j] = T(1)
			} else {
				C[j] = T(0)
			}
		}
	}
	return

}

// NeVV performs c := a ̅!= b where c is of the same type as the inputs.
func NeVV[T Num](a, b, c []T) {
	a = a[:]
	b = b[:len(a)]
	c = c[:len(a)]

	for i := range a {
		if a[i] != b[i] {
			c[i] = T(1)
		} else {
			c[i] = T(0)
		}
	}
}

// NeVVIter performs c := a  ̅!= b, where a, b, and c requires the use of an iterator.
func NeVVIter[T Num](a, b, c []T, ait, bit, cit Iterator) (err error) {
	var i, j, k int
	var validi, validj, validk bool
	var cisa, cisb bool
	if cisa, cisb, err = iterCheck3(a, b, c, ait, bit, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = ait.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if j, validj, err = bit.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}

		switch {
		case cisa:
			validk = validi
			k = i
		case cisb:
			validk = validj
			k = j
		default:
			if k, validk, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj && validk {
			if a[i] != b[j] {
				c[k] = T(1)
			} else {
				c[k] = T(0)
			}
		}
	}
	return
}

// NeVS performs c := vec ̅!= scalar where c is of the same datatype as its inputs. The scalar value is broadcasted for the operation.
func NeVS[T Num](a []T, b T, c []T) {
	a = a[:]
	c = c[:len(a)]

	for i := range a {
		if a[i] != b {
			c[i] = T(1)
		} else {
			c[i] = T(0)
		}
	}
}

// NeVSIter performs c := vec ̅!= scalar where c is of the same datatype as the inputs. The scalar value is broadcasted for the operation.
func NeVSIter[T Num](a []T, b T, c []T, ait, cit Iterator) (err error) {
	var i, j int
	var validi, validj bool
	var retIsVec bool
	if retIsVec, err = iterCheck2(a, c, ait, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = ait.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if retIsVec {
			j = i
			validj = validi
		} else {
			if j, validj, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj {
			if a[i] != b {
				c[j] = T(1)
			} else {
				c[j] = T(0)
			}
		}
	}
	return

}

// NeSV performs c := scalar ̅!= vec where c is of the same datatype as the inputs. The scalar value is broadcasted for the operation.
func NeSV[T Num](a T, b []T, c []T) {
	b = b[:]
	c = c[:len(b)]

	for i := range b {
		if a != b[i] {
			c[i] = T(1)
		} else {
			c[i] = T(0)
		}
	}
}

// NeSVIter performs c := scalar ̅!= vec where c is of the same datatype as the inputs. The scalar value is broadcasted for the operation.
func NeSVIter[T Num](a T, b []T, C []T, bit, cit Iterator) (err error) {
	var i, j int
	var validi, validj bool
	var retIsVec bool
	if retIsVec, err = iterCheck2(b, C, bit, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = bit.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if retIsVec {
			j = i
			validj = validi
		} else {
			if j, validj, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj {
			if a != b[i] {
				C[j] = T(1)
			} else {
				C[j] = T(0)
			}
		}
	}
	return

}

// LtVVBool performs c := a ̅< b.
func LtVVBool[T constraints.Ordered](a, b []T, c []bool) {
	a = a[:]
	b = b[:len(a)]
	c = c[:len(a)]

	for i := range a {
		c[i] = a[i] < b[i]
	}
}

// LtVVIterBool performs c := a  ̅< b, where a, b, and c requires the use of an iterator.
func LtVVIterBool[T constraints.Ordered](a, b []T, c []bool, ait, bit, cit Iterator) (err error) {
	var i, j, k int
	var validi, validj, validk bool
	var cisa, cisb bool
	if cisa, cisb, err = iterCheck3(a, b, c, ait, bit, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = ait.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if j, validj, err = bit.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}

		switch {
		case cisa:
			validk = validi
			k = i
		case cisb:
			validk = validj
			k = j
		default:
			if k, validk, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj && validk {
			c[k] = a[i] < b[j]
		}
	}
	return
}

// LtVSBool performs c := vec ̅< scalar. The scalar value is broadcasted for the operation.
func LtVSBool[T constraints.Ordered](a []T, b T, c []bool) {
	a = a[:]
	c = c[:len(a)]

	for i := range a {
		c[i] = a[i] < b
	}
}

// LtVSIterBool performs c := vec ̅< scalar. The scalar value is broadcasted for the operation.
func LtVSIterBool[T constraints.Ordered](a []T, b T, c []bool, ait, cit Iterator) (err error) {
	var i, j int
	var validi, validj bool
	var retIsVec bool
	if retIsVec, err = iterCheck2(a, c, ait, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = ait.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if retIsVec {
			j = i
			validj = validi
		} else {
			if j, validj, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj {
			c[j] = a[i] < b
		}
	}
	return

}

// LtSVBool performs c := scalar ̅< vec. The scalar value is broadcasted for the operation.
func LtSVBool[T constraints.Ordered](a T, b []T, c []bool) {
	b = b[:]
	c = c[:len(b)]

	for i := range b {
		c[i] = a < b[i]
	}
}

// LtSVIterBool performs c := scalar ̅< vec. The scalar value is broadcasted for the operation.
func LtSVIterBool[T constraints.Ordered](a T, b []T, c []bool, bit, cit Iterator) (err error) {
	var i, j int
	var validi, validj bool
	var retIsVec bool
	if retIsVec, err = iterCheck2(b, c, bit, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = bit.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if retIsVec {
			j = i
			validj = validi
		} else {
			if j, validj, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj {
			c[j] = a < b[i]
		}
	}
	return

}

// LteVVBool performs c := a ̅<= b.
func LteVVBool[T constraints.Ordered](a, b []T, c []bool) {
	a = a[:]
	b = b[:len(a)]
	c = c[:len(a)]

	for i := range a {
		c[i] = a[i] <= b[i]
	}
}

// LteVVIterBool performs c := a  ̅<= b, where a, b, and c requires the use of an iterator.
func LteVVIterBool[T constraints.Ordered](a, b []T, c []bool, ait, bit, cit Iterator) (err error) {
	var i, j, k int
	var validi, validj, validk bool
	var cisa, cisb bool
	if cisa, cisb, err = iterCheck3(a, b, c, ait, bit, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = ait.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if j, validj, err = bit.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}

		switch {
		case cisa:
			validk = validi
			k = i
		case cisb:
			validk = validj
			k = j
		default:
			if k, validk, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj && validk {
			c[k] = a[i] <= b[j]
		}
	}
	return
}

// LteVSBool performs c := vec ̅<= scalar. The scalar value is broadcasted for the operation.
func LteVSBool[T constraints.Ordered](a []T, b T, c []bool) {
	a = a[:]
	c = c[:len(a)]

	for i := range a {
		c[i] = a[i] <= b
	}
}

// LteVSIterBool performs c := vec ̅<= scalar. The scalar value is broadcasted for the operation.
func LteVSIterBool[T constraints.Ordered](a []T, b T, c []bool, ait, cit Iterator) (err error) {
	var i, j int
	var validi, validj bool
	var retIsVec bool
	if retIsVec, err = iterCheck2(a, c, ait, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = ait.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if retIsVec {
			j = i
			validj = validi
		} else {
			if j, validj, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj {
			c[j] = a[i] <= b
		}
	}
	return

}

// LteSVBool performs c := scalar ̅<= vec. The scalar value is broadcasted for the operation.
func LteSVBool[T constraints.Ordered](a T, b []T, c []bool) {
	b = b[:]
	c = c[:len(b)]

	for i := range b {
		c[i] = a <= b[i]
	}
}

// LteSVIterBool performs c := scalar ̅<= vec. The scalar value is broadcasted for the operation.
func LteSVIterBool[T constraints.Ordered](a T, b []T, c []bool, bit, cit Iterator) (err error) {
	var i, j int
	var validi, validj bool
	var retIsVec bool
	if retIsVec, err = iterCheck2(b, c, bit, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = bit.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if retIsVec {
			j = i
			validj = validi
		} else {
			if j, validj, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj {
			c[j] = a <= b[i]
		}
	}
	return

}

// GtVVBool performs c := a ̅> b.
func GtVVBool[T constraints.Ordered](a, b []T, c []bool) {
	a = a[:]
	b = b[:len(a)]
	c = c[:len(a)]

	for i := range a {
		c[i] = a[i] > b[i]
	}
}

// GtVVIterBool performs c := a  ̅> b, where a, b, and c requires the use of an iterator.
func GtVVIterBool[T constraints.Ordered](a, b []T, c []bool, ait, bit, cit Iterator) (err error) {
	var i, j, k int
	var validi, validj, validk bool
	var cisa, cisb bool
	if cisa, cisb, err = iterCheck3(a, b, c, ait, bit, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = ait.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if j, validj, err = bit.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}

		switch {
		case cisa:
			validk = validi
			k = i
		case cisb:
			validk = validj
			k = j
		default:
			if k, validk, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj && validk {
			c[k] = a[i] > b[j]
		}
	}
	return
}

// GtVSBool performs c := vec ̅> scalar. The scalar value is broadcasted for the operation.
func GtVSBool[T constraints.Ordered](a []T, b T, c []bool) {
	a = a[:]
	c = c[:len(a)]

	for i := range a {
		c[i] = a[i] > b
	}
}

// GtVSIterBool performs c := vec ̅> scalar. The scalar value is broadcasted for the operation.
func GtVSIterBool[T constraints.Ordered](a []T, b T, c []bool, ait, cit Iterator) (err error) {
	var i, j int
	var validi, validj bool
	var retIsVec bool
	if retIsVec, err = iterCheck2(a, c, ait, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = ait.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if retIsVec {
			j = i
			validj = validi
		} else {
			if j, validj, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj {
			c[j] = a[i] > b
		}
	}
	return

}

// GtSVBool performs c := scalar ̅> vec. The scalar value is broadcasted for the operation.
func GtSVBool[T constraints.Ordered](a T, b []T, c []bool) {
	b = b[:]
	c = c[:len(b)]

	for i := range b {
		c[i] = a > b[i]
	}
}

// GtSVIterBool performs c := scalar ̅> vec. The scalar value is broadcasted for the operation.
func GtSVIterBool[T constraints.Ordered](a T, b []T, c []bool, bit, cit Iterator) (err error) {
	var i, j int
	var validi, validj bool
	var retIsVec bool
	if retIsVec, err = iterCheck2(b, c, bit, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = bit.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if retIsVec {
			j = i
			validj = validi
		} else {
			if j, validj, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj {
			c[j] = a > b[i]
		}
	}
	return

}

// GteVVBool performs c := a ̅>= b.
func GteVVBool[T constraints.Ordered](a, b []T, c []bool) {
	a = a[:]
	b = b[:len(a)]
	c = c[:len(a)]

	for i := range a {
		c[i] = a[i] >= b[i]
	}
}

// GteVVIterBool performs c := a  ̅>= b, where a, b, and c requires the use of an iterator.
func GteVVIterBool[T constraints.Ordered](a, b []T, c []bool, ait, bit, cit Iterator) (err error) {
	var i, j, k int
	var validi, validj, validk bool
	var cisa, cisb bool
	if cisa, cisb, err = iterCheck3(a, b, c, ait, bit, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = ait.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if j, validj, err = bit.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}

		switch {
		case cisa:
			validk = validi
			k = i
		case cisb:
			validk = validj
			k = j
		default:
			if k, validk, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj && validk {
			c[k] = a[i] >= b[j]
		}
	}
	return
}

// GteVSBool performs c := vec ̅>= scalar. The scalar value is broadcasted for the operation.
func GteVSBool[T constraints.Ordered](a []T, b T, c []bool) {
	a = a[:]
	c = c[:len(a)]

	for i := range a {
		c[i] = a[i] >= b
	}
}

// GteVSIterBool performs c := vec ̅>= scalar. The scalar value is broadcasted for the operation.
func GteVSIterBool[T constraints.Ordered](a []T, b T, c []bool, ait, cit Iterator) (err error) {
	var i, j int
	var validi, validj bool
	var retIsVec bool
	if retIsVec, err = iterCheck2(a, c, ait, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = ait.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if retIsVec {
			j = i
			validj = validi
		} else {
			if j, validj, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj {
			c[j] = a[i] >= b
		}
	}
	return

}

// GteSVBool performs c := scalar ̅>= vec. The scalar value is broadcasted for the operation.
func GteSVBool[T constraints.Ordered](a T, b []T, c []bool) {
	b = b[:]
	c = c[:len(b)]

	for i := range b {
		c[i] = a >= b[i]
	}
}

// GteSVIterBool performs c := scalar ̅>= vec. The scalar value is broadcasted for the operation.
func GteSVIterBool[T constraints.Ordered](a T, b []T, c []bool, bit, cit Iterator) (err error) {
	var i, j int
	var validi, validj bool
	var retIsVec bool
	if retIsVec, err = iterCheck2(b, c, bit, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = bit.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if retIsVec {
			j = i
			validj = validi
		} else {
			if j, validj, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj {
			c[j] = a >= b[i]
		}
	}
	return

}

// ElEqVVBool performs c := a ̅== b.
func ElEqVVBool[T comparable](a, b []T, c []bool) {
	a = a[:]
	b = b[:len(a)]
	c = c[:len(a)]

	for i := range a {
		c[i] = a[i] == b[i]
	}
}

// ElEqVVIterBool performs c := a  ̅== b, where a, b, and c requires the use of an iterator.
func ElEqVVIterBool[T comparable](a, b []T, c []bool, ait, bit, cit Iterator) (err error) {
	var i, j, k int
	var validi, validj, validk bool
	var cisa, cisb bool
	if cisa, cisb, err = iterCheck3(a, b, c, ait, bit, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = ait.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if j, validj, err = bit.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}

		switch {
		case cisa:
			validk = validi
			k = i
		case cisb:
			validk = validj
			k = j
		default:
			if k, validk, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj && validk {
			c[k] = a[i] == b[j]
		}
	}
	return
}

// ElEqVSBool performs c := vec ̅== scalar. The scalar value is broadcasted for the operation.
func ElEqVSBool[T comparable](a []T, b T, c []bool) {
	a = a[:]
	c = c[:len(a)]

	for i := range a {
		c[i] = a[i] == b
	}
}

// ElEqVSIterBool performs c := vec ̅== scalar. The scalar value is broadcasted for the operation.
func ElEqVSIterBool[T comparable](a []T, b T, c []bool, ait, cit Iterator) (err error) {
	var i, j int
	var validi, validj bool
	var retIsVec bool
	if retIsVec, err = iterCheck2(a, c, ait, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = ait.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if retIsVec {
			j = i
			validj = validi
		} else {
			if j, validj, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj {
			c[j] = a[i] == b
		}
	}
	return

}

// ElEqSVBool performs c := scalar ̅== vec. The scalar value is broadcasted for the operation.
func ElEqSVBool[T comparable](a T, b []T, c []bool) {
	b = b[:]
	c = c[:len(b)]

	for i := range b {
		c[i] = a == b[i]
	}
}

// ElEqSVIterBool performs c := scalar ̅== vec. The scalar value is broadcasted for the operation.
func ElEqSVIterBool[T comparable](a T, b []T, c []bool, bit, cit Iterator) (err error) {
	var i, j int
	var validi, validj bool
	var retIsVec bool
	if retIsVec, err = iterCheck2(b, c, bit, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = bit.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if retIsVec {
			j = i
			validj = validi
		} else {
			if j, validj, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj {
			c[j] = a == b[i]
		}
	}
	return

}

// NeVVBool performs c := a ̅!= b.
func NeVVBool[T comparable](a, b []T, c []bool) {
	a = a[:]
	b = b[:len(a)]
	c = c[:len(a)]

	for i := range a {
		c[i] = a[i] != b[i]
	}
}

// NeVVIterBool performs c := a  ̅!= b, where a, b, and c requires the use of an iterator.
func NeVVIterBool[T comparable](a, b []T, c []bool, ait, bit, cit Iterator) (err error) {
	var i, j, k int
	var validi, validj, validk bool
	var cisa, cisb bool
	if cisa, cisb, err = iterCheck3(a, b, c, ait, bit, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = ait.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if j, validj, err = bit.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}

		switch {
		case cisa:
			validk = validi
			k = i
		case cisb:
			validk = validj
			k = j
		default:
			if k, validk, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj && validk {
			c[k] = a[i] != b[j]
		}
	}
	return
}

// NeVSBool performs c := vec ̅!= scalar. The scalar value is broadcasted for the operation.
func NeVSBool[T comparable](a []T, b T, c []bool) {
	a = a[:]
	c = c[:len(a)]

	for i := range a {
		c[i] = a[i] != b
	}
}

// NeVSIterBool performs c := vec ̅!= scalar. The scalar value is broadcasted for the operation.
func NeVSIterBool[T comparable](a []T, b T, c []bool, ait, cit Iterator) (err error) {
	var i, j int
	var validi, validj bool
	var retIsVec bool
	if retIsVec, err = iterCheck2(a, c, ait, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = ait.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if retIsVec {
			j = i
			validj = validi
		} else {
			if j, validj, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj {
			c[j] = a[i] != b
		}
	}
	return

}

// NeSVBool performs c := scalar ̅!= vec. The scalar value is broadcasted for the operation.
func NeSVBool[T comparable](a T, b []T, c []bool) {
	b = b[:]
	c = c[:len(b)]

	for i := range b {
		c[i] = a != b[i]
	}
}

// NeSVIterBool performs c := scalar ̅!= vec. The scalar value is broadcasted for the operation.
func NeSVIterBool[T comparable](a T, b []T, c []bool, bit, cit Iterator) (err error) {
	var i, j int
	var validi, validj bool
	var retIsVec bool
	if retIsVec, err = iterCheck2(b, c, bit, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = bit.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if retIsVec {
			j = i
			validj = validi
		} else {
			if j, validj, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj {
			c[j] = a != b[i]
		}
	}
	return

}
