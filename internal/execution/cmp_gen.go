// Code generated by genlib3. DO NOT EDIT

package execution

import (
	"golang.org/x/exp/constraints"
	"gorgonia.org/shapes"
	"gorgonia.org/tensor/internal"
	"gorgonia.org/tensor/internal/errors"
)

// LtVV performs c := a ̅< b where c is of the same type as the inputs.
func LtVV[T OrderedNum](a, b, c []T) {
	a = a[:]
	b = b[:len(a)]
	c = c[:len(a)]

	for i := range a {
		if a[i] < b[i] {
			c[i] = T(1)
		} else {
			c[i] = T(0)
		}
	}
}

// LtBC performs c := a ̅< b where c is of the same type as the inputs, using the appropriate indexing that follows a broadcast operation.
func LtBC[T OrderedNum](a, b, c []T, aShp, bShp, cShp shapes.Shape, aStrides, bStrides []int) {
	for i := range c {
		var idxA, idxB int
		for j := range cShp {
			aDim, bDim := 1, 1
			if j < aShp.Dims() {
				aDim = aShp[j]
			}
			if j < bShp.Dims() {
				bDim = bShp[j]
			}
			idxDim := (i / cShp[j+1:].TotalSize()) % cShp[j]
			if aDim != 1 {
				idxA += (idxDim % aDim) * aStrides[j]
			}
			if bDim != 1 {
				idxB += (idxDim % bDim) * bStrides[j]
			}
		}
		if a[idxA] < b[idxB] {
			c[i] = T(1)
		} else {
			c[i] = T(0)
		}
	}
}

// LtVVIter performs c := a  ̅< b, where a, b, and c requires the use of an iterator.
func LtVVIter[T OrderedNum](a, b, c []T, ait, bit, cit Iterator) (err error) {
	var i, j, k int
	var validi, validj, validk bool
	var cisa, cisb bool
	if cisa, cisb, err = iterCheck3(a, b, c, ait, bit, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = ait.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if j, validj, err = bit.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}

		switch {
		case cisa:
			validk = validi
			k = i
		case cisb:
			validk = validj
			k = j
		default:
			if k, validk, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj && validk {
			if a[i] < b[j] {
				c[k] = T(1)
			} else {
				c[k] = T(0)
			}
		}
	}
	return
}

// LtVS performs c := vec ̅< scalar where c is of the same datatype as its inputs. The scalar value is broadcasted for the operation.
func LtVS[T OrderedNum](a []T, b T, c []T) {
	a = a[:]
	c = c[:len(a)]

	for i := range a {
		if a[i] < b {
			c[i] = T(1)
		} else {
			c[i] = T(0)
		}
	}
}

// LtVSIter performs c := vec ̅< scalar where c is of the same datatype as the inputs. The scalar value is broadcasted for the operation.
func LtVSIter[T OrderedNum](a []T, b T, c []T, ait, cit Iterator) (err error) {
	var i, j int
	var validi, validj bool
	var retIsVec bool
	if retIsVec, err = iterCheck2(a, c, ait, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = ait.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if retIsVec {
			j = i
			validj = validi
		} else {
			if j, validj, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj {
			if a[i] < b {
				c[j] = T(1)
			} else {
				c[j] = T(0)
			}
		}
	}
	return

}

// LtSV performs c := scalar ̅< vec where c is of the same datatype as the inputs. The scalar value is broadcasted for the operation.
func LtSV[T OrderedNum](a T, b []T, c []T) {
	b = b[:]
	c = c[:len(b)]

	for i := range b {
		if a < b[i] {
			c[i] = T(1)
		} else {
			c[i] = T(0)
		}
	}
}

// LtSVIter performs c := scalar ̅< vec where c is of the same datatype as the inputs. The scalar value is broadcasted for the operation.
func LtSVIter[T OrderedNum](a T, b []T, C []T, bit, cit Iterator) (err error) {
	var i, j int
	var validi, validj bool
	var retIsVec bool
	if retIsVec, err = iterCheck2(b, C, bit, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = bit.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if retIsVec {
			j = i
			validj = validi
		} else {
			if j, validj, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj {
			if a < b[i] {
				C[j] = T(1)
			} else {
				C[j] = T(0)
			}
		}
	}
	return

}

// LteVV performs c := a ̅<= b where c is of the same type as the inputs.
func LteVV[T OrderedNum](a, b, c []T) {
	a = a[:]
	b = b[:len(a)]
	c = c[:len(a)]

	for i := range a {
		if a[i] <= b[i] {
			c[i] = T(1)
		} else {
			c[i] = T(0)
		}
	}
}

// LteBC performs c := a ̅<= b where c is of the same type as the inputs, using the appropriate indexing that follows a broadcast operation.
func LteBC[T OrderedNum](a, b, c []T, aShp, bShp, cShp shapes.Shape, aStrides, bStrides []int) {
	for i := range c {
		var idxA, idxB int
		for j := range cShp {
			aDim, bDim := 1, 1
			if j < aShp.Dims() {
				aDim = aShp[j]
			}
			if j < bShp.Dims() {
				bDim = bShp[j]
			}
			idxDim := (i / cShp[j+1:].TotalSize()) % cShp[j]
			if aDim != 1 {
				idxA += (idxDim % aDim) * aStrides[j]
			}
			if bDim != 1 {
				idxB += (idxDim % bDim) * bStrides[j]
			}
		}
		if a[idxA] <= b[idxB] {
			c[i] = T(1)
		} else {
			c[i] = T(0)
		}
	}
}

// LteVVIter performs c := a  ̅<= b, where a, b, and c requires the use of an iterator.
func LteVVIter[T OrderedNum](a, b, c []T, ait, bit, cit Iterator) (err error) {
	var i, j, k int
	var validi, validj, validk bool
	var cisa, cisb bool
	if cisa, cisb, err = iterCheck3(a, b, c, ait, bit, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = ait.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if j, validj, err = bit.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}

		switch {
		case cisa:
			validk = validi
			k = i
		case cisb:
			validk = validj
			k = j
		default:
			if k, validk, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj && validk {
			if a[i] <= b[j] {
				c[k] = T(1)
			} else {
				c[k] = T(0)
			}
		}
	}
	return
}

// LteVS performs c := vec ̅<= scalar where c is of the same datatype as its inputs. The scalar value is broadcasted for the operation.
func LteVS[T OrderedNum](a []T, b T, c []T) {
	a = a[:]
	c = c[:len(a)]

	for i := range a {
		if a[i] <= b {
			c[i] = T(1)
		} else {
			c[i] = T(0)
		}
	}
}

// LteVSIter performs c := vec ̅<= scalar where c is of the same datatype as the inputs. The scalar value is broadcasted for the operation.
func LteVSIter[T OrderedNum](a []T, b T, c []T, ait, cit Iterator) (err error) {
	var i, j int
	var validi, validj bool
	var retIsVec bool
	if retIsVec, err = iterCheck2(a, c, ait, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = ait.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if retIsVec {
			j = i
			validj = validi
		} else {
			if j, validj, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj {
			if a[i] <= b {
				c[j] = T(1)
			} else {
				c[j] = T(0)
			}
		}
	}
	return

}

// LteSV performs c := scalar ̅<= vec where c is of the same datatype as the inputs. The scalar value is broadcasted for the operation.
func LteSV[T OrderedNum](a T, b []T, c []T) {
	b = b[:]
	c = c[:len(b)]

	for i := range b {
		if a <= b[i] {
			c[i] = T(1)
		} else {
			c[i] = T(0)
		}
	}
}

// LteSVIter performs c := scalar ̅<= vec where c is of the same datatype as the inputs. The scalar value is broadcasted for the operation.
func LteSVIter[T OrderedNum](a T, b []T, C []T, bit, cit Iterator) (err error) {
	var i, j int
	var validi, validj bool
	var retIsVec bool
	if retIsVec, err = iterCheck2(b, C, bit, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = bit.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if retIsVec {
			j = i
			validj = validi
		} else {
			if j, validj, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj {
			if a <= b[i] {
				C[j] = T(1)
			} else {
				C[j] = T(0)
			}
		}
	}
	return

}

// GtVV performs c := a ̅> b where c is of the same type as the inputs.
func GtVV[T OrderedNum](a, b, c []T) {
	a = a[:]
	b = b[:len(a)]
	c = c[:len(a)]

	for i := range a {
		if a[i] > b[i] {
			c[i] = T(1)
		} else {
			c[i] = T(0)
		}
	}
}

// GtBC performs c := a ̅> b where c is of the same type as the inputs, using the appropriate indexing that follows a broadcast operation.
func GtBC[T OrderedNum](a, b, c []T, aShp, bShp, cShp shapes.Shape, aStrides, bStrides []int) {
	for i := range c {
		var idxA, idxB int
		for j := range cShp {
			aDim, bDim := 1, 1
			if j < aShp.Dims() {
				aDim = aShp[j]
			}
			if j < bShp.Dims() {
				bDim = bShp[j]
			}
			idxDim := (i / cShp[j+1:].TotalSize()) % cShp[j]
			if aDim != 1 {
				idxA += (idxDim % aDim) * aStrides[j]
			}
			if bDim != 1 {
				idxB += (idxDim % bDim) * bStrides[j]
			}
		}
		if a[idxA] > b[idxB] {
			c[i] = T(1)
		} else {
			c[i] = T(0)
		}
	}
}

// GtVVIter performs c := a  ̅> b, where a, b, and c requires the use of an iterator.
func GtVVIter[T OrderedNum](a, b, c []T, ait, bit, cit Iterator) (err error) {
	var i, j, k int
	var validi, validj, validk bool
	var cisa, cisb bool
	if cisa, cisb, err = iterCheck3(a, b, c, ait, bit, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = ait.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if j, validj, err = bit.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}

		switch {
		case cisa:
			validk = validi
			k = i
		case cisb:
			validk = validj
			k = j
		default:
			if k, validk, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj && validk {
			if a[i] > b[j] {
				c[k] = T(1)
			} else {
				c[k] = T(0)
			}
		}
	}
	return
}

// GtVS performs c := vec ̅> scalar where c is of the same datatype as its inputs. The scalar value is broadcasted for the operation.
func GtVS[T OrderedNum](a []T, b T, c []T) {
	a = a[:]
	c = c[:len(a)]

	for i := range a {
		if a[i] > b {
			c[i] = T(1)
		} else {
			c[i] = T(0)
		}
	}
}

// GtVSIter performs c := vec ̅> scalar where c is of the same datatype as the inputs. The scalar value is broadcasted for the operation.
func GtVSIter[T OrderedNum](a []T, b T, c []T, ait, cit Iterator) (err error) {
	var i, j int
	var validi, validj bool
	var retIsVec bool
	if retIsVec, err = iterCheck2(a, c, ait, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = ait.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if retIsVec {
			j = i
			validj = validi
		} else {
			if j, validj, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj {
			if a[i] > b {
				c[j] = T(1)
			} else {
				c[j] = T(0)
			}
		}
	}
	return

}

// GtSV performs c := scalar ̅> vec where c is of the same datatype as the inputs. The scalar value is broadcasted for the operation.
func GtSV[T OrderedNum](a T, b []T, c []T) {
	b = b[:]
	c = c[:len(b)]

	for i := range b {
		if a > b[i] {
			c[i] = T(1)
		} else {
			c[i] = T(0)
		}
	}
}

// GtSVIter performs c := scalar ̅> vec where c is of the same datatype as the inputs. The scalar value is broadcasted for the operation.
func GtSVIter[T OrderedNum](a T, b []T, C []T, bit, cit Iterator) (err error) {
	var i, j int
	var validi, validj bool
	var retIsVec bool
	if retIsVec, err = iterCheck2(b, C, bit, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = bit.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if retIsVec {
			j = i
			validj = validi
		} else {
			if j, validj, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj {
			if a > b[i] {
				C[j] = T(1)
			} else {
				C[j] = T(0)
			}
		}
	}
	return

}

// GteVV performs c := a ̅>= b where c is of the same type as the inputs.
func GteVV[T OrderedNum](a, b, c []T) {
	a = a[:]
	b = b[:len(a)]
	c = c[:len(a)]

	for i := range a {
		if a[i] >= b[i] {
			c[i] = T(1)
		} else {
			c[i] = T(0)
		}
	}
}

// GteBC performs c := a ̅>= b where c is of the same type as the inputs, using the appropriate indexing that follows a broadcast operation.
func GteBC[T OrderedNum](a, b, c []T, aShp, bShp, cShp shapes.Shape, aStrides, bStrides []int) {
	for i := range c {
		var idxA, idxB int
		for j := range cShp {
			aDim, bDim := 1, 1
			if j < aShp.Dims() {
				aDim = aShp[j]
			}
			if j < bShp.Dims() {
				bDim = bShp[j]
			}
			idxDim := (i / cShp[j+1:].TotalSize()) % cShp[j]
			if aDim != 1 {
				idxA += (idxDim % aDim) * aStrides[j]
			}
			if bDim != 1 {
				idxB += (idxDim % bDim) * bStrides[j]
			}
		}
		if a[idxA] >= b[idxB] {
			c[i] = T(1)
		} else {
			c[i] = T(0)
		}
	}
}

// GteVVIter performs c := a  ̅>= b, where a, b, and c requires the use of an iterator.
func GteVVIter[T OrderedNum](a, b, c []T, ait, bit, cit Iterator) (err error) {
	var i, j, k int
	var validi, validj, validk bool
	var cisa, cisb bool
	if cisa, cisb, err = iterCheck3(a, b, c, ait, bit, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = ait.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if j, validj, err = bit.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}

		switch {
		case cisa:
			validk = validi
			k = i
		case cisb:
			validk = validj
			k = j
		default:
			if k, validk, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj && validk {
			if a[i] >= b[j] {
				c[k] = T(1)
			} else {
				c[k] = T(0)
			}
		}
	}
	return
}

// GteVS performs c := vec ̅>= scalar where c is of the same datatype as its inputs. The scalar value is broadcasted for the operation.
func GteVS[T OrderedNum](a []T, b T, c []T) {
	a = a[:]
	c = c[:len(a)]

	for i := range a {
		if a[i] >= b {
			c[i] = T(1)
		} else {
			c[i] = T(0)
		}
	}
}

// GteVSIter performs c := vec ̅>= scalar where c is of the same datatype as the inputs. The scalar value is broadcasted for the operation.
func GteVSIter[T OrderedNum](a []T, b T, c []T, ait, cit Iterator) (err error) {
	var i, j int
	var validi, validj bool
	var retIsVec bool
	if retIsVec, err = iterCheck2(a, c, ait, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = ait.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if retIsVec {
			j = i
			validj = validi
		} else {
			if j, validj, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj {
			if a[i] >= b {
				c[j] = T(1)
			} else {
				c[j] = T(0)
			}
		}
	}
	return

}

// GteSV performs c := scalar ̅>= vec where c is of the same datatype as the inputs. The scalar value is broadcasted for the operation.
func GteSV[T OrderedNum](a T, b []T, c []T) {
	b = b[:]
	c = c[:len(b)]

	for i := range b {
		if a >= b[i] {
			c[i] = T(1)
		} else {
			c[i] = T(0)
		}
	}
}

// GteSVIter performs c := scalar ̅>= vec where c is of the same datatype as the inputs. The scalar value is broadcasted for the operation.
func GteSVIter[T OrderedNum](a T, b []T, C []T, bit, cit Iterator) (err error) {
	var i, j int
	var validi, validj bool
	var retIsVec bool
	if retIsVec, err = iterCheck2(b, C, bit, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = bit.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if retIsVec {
			j = i
			validj = validi
		} else {
			if j, validj, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj {
			if a >= b[i] {
				C[j] = T(1)
			} else {
				C[j] = T(0)
			}
		}
	}
	return

}

// ElEqVV performs c := a ̅== b where c is of the same type as the inputs.
func ElEqVV[T Num](a, b, c []T) {
	a = a[:]
	b = b[:len(a)]
	c = c[:len(a)]

	for i := range a {
		if a[i] == b[i] {
			c[i] = T(1)
		} else {
			c[i] = T(0)
		}
	}
}

// ElEqBC performs c := a ̅== b where c is of the same type as the inputs, using the appropriate indexing that follows a broadcast operation.
func ElEqBC[T Num](a, b, c []T, aShp, bShp, cShp shapes.Shape, aStrides, bStrides []int) {
	for i := range c {
		var idxA, idxB int
		for j := range cShp {
			aDim, bDim := 1, 1
			if j < aShp.Dims() {
				aDim = aShp[j]
			}
			if j < bShp.Dims() {
				bDim = bShp[j]
			}
			idxDim := (i / cShp[j+1:].TotalSize()) % cShp[j]
			if aDim != 1 {
				idxA += (idxDim % aDim) * aStrides[j]
			}
			if bDim != 1 {
				idxB += (idxDim % bDim) * bStrides[j]
			}
		}
		if a[idxA] == b[idxB] {
			c[i] = T(1)
		} else {
			c[i] = T(0)
		}
	}
}

// ElEqVVIter performs c := a  ̅== b, where a, b, and c requires the use of an iterator.
func ElEqVVIter[T Num](a, b, c []T, ait, bit, cit Iterator) (err error) {
	var i, j, k int
	var validi, validj, validk bool
	var cisa, cisb bool
	if cisa, cisb, err = iterCheck3(a, b, c, ait, bit, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = ait.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if j, validj, err = bit.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}

		switch {
		case cisa:
			validk = validi
			k = i
		case cisb:
			validk = validj
			k = j
		default:
			if k, validk, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj && validk {
			if a[i] == b[j] {
				c[k] = T(1)
			} else {
				c[k] = T(0)
			}
		}
	}
	return
}

// ElEqVS performs c := vec ̅== scalar where c is of the same datatype as its inputs. The scalar value is broadcasted for the operation.
func ElEqVS[T Num](a []T, b T, c []T) {
	a = a[:]
	c = c[:len(a)]

	for i := range a {
		if a[i] == b {
			c[i] = T(1)
		} else {
			c[i] = T(0)
		}
	}
}

// ElEqVSIter performs c := vec ̅== scalar where c is of the same datatype as the inputs. The scalar value is broadcasted for the operation.
func ElEqVSIter[T Num](a []T, b T, c []T, ait, cit Iterator) (err error) {
	var i, j int
	var validi, validj bool
	var retIsVec bool
	if retIsVec, err = iterCheck2(a, c, ait, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = ait.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if retIsVec {
			j = i
			validj = validi
		} else {
			if j, validj, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj {
			if a[i] == b {
				c[j] = T(1)
			} else {
				c[j] = T(0)
			}
		}
	}
	return

}

// ElEqSV performs c := scalar ̅== vec where c is of the same datatype as the inputs. The scalar value is broadcasted for the operation.
func ElEqSV[T Num](a T, b []T, c []T) {
	b = b[:]
	c = c[:len(b)]

	for i := range b {
		if a == b[i] {
			c[i] = T(1)
		} else {
			c[i] = T(0)
		}
	}
}

// ElEqSVIter performs c := scalar ̅== vec where c is of the same datatype as the inputs. The scalar value is broadcasted for the operation.
func ElEqSVIter[T Num](a T, b []T, C []T, bit, cit Iterator) (err error) {
	var i, j int
	var validi, validj bool
	var retIsVec bool
	if retIsVec, err = iterCheck2(b, C, bit, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = bit.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if retIsVec {
			j = i
			validj = validi
		} else {
			if j, validj, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj {
			if a == b[i] {
				C[j] = T(1)
			} else {
				C[j] = T(0)
			}
		}
	}
	return

}

// ElNeVV performs c := a ̅!= b where c is of the same type as the inputs.
func ElNeVV[T Num](a, b, c []T) {
	a = a[:]
	b = b[:len(a)]
	c = c[:len(a)]

	for i := range a {
		if a[i] != b[i] {
			c[i] = T(1)
		} else {
			c[i] = T(0)
		}
	}
}

// ElNeBC performs c := a ̅!= b where c is of the same type as the inputs, using the appropriate indexing that follows a broadcast operation.
func ElNeBC[T Num](a, b, c []T, aShp, bShp, cShp shapes.Shape, aStrides, bStrides []int) {
	for i := range c {
		var idxA, idxB int
		for j := range cShp {
			aDim, bDim := 1, 1
			if j < aShp.Dims() {
				aDim = aShp[j]
			}
			if j < bShp.Dims() {
				bDim = bShp[j]
			}
			idxDim := (i / cShp[j+1:].TotalSize()) % cShp[j]
			if aDim != 1 {
				idxA += (idxDim % aDim) * aStrides[j]
			}
			if bDim != 1 {
				idxB += (idxDim % bDim) * bStrides[j]
			}
		}
		if a[idxA] != b[idxB] {
			c[i] = T(1)
		} else {
			c[i] = T(0)
		}
	}
}

// ElNeVVIter performs c := a  ̅!= b, where a, b, and c requires the use of an iterator.
func ElNeVVIter[T Num](a, b, c []T, ait, bit, cit Iterator) (err error) {
	var i, j, k int
	var validi, validj, validk bool
	var cisa, cisb bool
	if cisa, cisb, err = iterCheck3(a, b, c, ait, bit, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = ait.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if j, validj, err = bit.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}

		switch {
		case cisa:
			validk = validi
			k = i
		case cisb:
			validk = validj
			k = j
		default:
			if k, validk, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj && validk {
			if a[i] != b[j] {
				c[k] = T(1)
			} else {
				c[k] = T(0)
			}
		}
	}
	return
}

// ElNeVS performs c := vec ̅!= scalar where c is of the same datatype as its inputs. The scalar value is broadcasted for the operation.
func ElNeVS[T Num](a []T, b T, c []T) {
	a = a[:]
	c = c[:len(a)]

	for i := range a {
		if a[i] != b {
			c[i] = T(1)
		} else {
			c[i] = T(0)
		}
	}
}

// ElNeVSIter performs c := vec ̅!= scalar where c is of the same datatype as the inputs. The scalar value is broadcasted for the operation.
func ElNeVSIter[T Num](a []T, b T, c []T, ait, cit Iterator) (err error) {
	var i, j int
	var validi, validj bool
	var retIsVec bool
	if retIsVec, err = iterCheck2(a, c, ait, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = ait.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if retIsVec {
			j = i
			validj = validi
		} else {
			if j, validj, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj {
			if a[i] != b {
				c[j] = T(1)
			} else {
				c[j] = T(0)
			}
		}
	}
	return

}

// ElNeSV performs c := scalar ̅!= vec where c is of the same datatype as the inputs. The scalar value is broadcasted for the operation.
func ElNeSV[T Num](a T, b []T, c []T) {
	b = b[:]
	c = c[:len(b)]

	for i := range b {
		if a != b[i] {
			c[i] = T(1)
		} else {
			c[i] = T(0)
		}
	}
}

// ElNeSVIter performs c := scalar ̅!= vec where c is of the same datatype as the inputs. The scalar value is broadcasted for the operation.
func ElNeSVIter[T Num](a T, b []T, C []T, bit, cit Iterator) (err error) {
	var i, j int
	var validi, validj bool
	var retIsVec bool
	if retIsVec, err = iterCheck2(b, C, bit, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = bit.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if retIsVec {
			j = i
			validj = validi
		} else {
			if j, validj, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj {
			if a != b[i] {
				C[j] = T(1)
			} else {
				C[j] = T(0)
			}
		}
	}
	return

}

// LtVVBool performs c := a ̅< b.
func LtVVBool[T constraints.Ordered](a, b []T, c []bool) {
	a = a[:]
	b = b[:len(a)]
	c = c[:len(a)]

	for i := range a {
		c[i] = a[i] < b[i]
	}
}

// LtBCBool performs c := a ̅< b, using the appropriate indexing that follows a broadcast operation.
func LtBCBool[T constraints.Ordered](a, b []T, c []bool, aShp, bShp, cShp shapes.Shape, aStrides, bStrides []int) {
	for i := range c {
		var idxA, idxB int
		for j := range cShp {
			aDim, bDim := 1, 1
			if j < aShp.Dims() {
				aDim = aShp[j]
			}
			if j < bShp.Dims() {
				bDim = bShp[j]
			}
			idxDim := (i / cShp[j+1:].TotalSize()) % cShp[j]
			if aDim != 1 {
				idxA += (idxDim % aDim) * aStrides[j]
			}
			if bDim != 1 {
				idxB += (idxDim % bDim) * bStrides[j]
			}
		}
		c[i] = a[idxA] < b[idxB]
	}
}

// LtVVIterBool performs c := a  ̅< b, where a, b, and c requires the use of an iterator.
func LtVVIterBool[T constraints.Ordered](a, b []T, c []bool, ait, bit, cit Iterator) (err error) {
	var i, j, k int
	var validi, validj, validk bool
	var cisa, cisb bool
	if cisa, cisb, err = iterCheck3(a, b, c, ait, bit, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = ait.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if j, validj, err = bit.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}

		switch {
		case cisa:
			validk = validi
			k = i
		case cisb:
			validk = validj
			k = j
		default:
			if k, validk, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj && validk {
			c[k] = a[i] < b[j]
		}
	}
	return
}

// LtVSBool performs c := vec ̅< scalar. The scalar value is broadcasted for the operation.
func LtVSBool[T constraints.Ordered](a []T, b T, c []bool) {
	a = a[:]
	c = c[:len(a)]

	for i := range a {
		c[i] = a[i] < b
	}
}

// LtVSIterBool performs c := vec ̅< scalar. The scalar value is broadcasted for the operation.
func LtVSIterBool[T constraints.Ordered](a []T, b T, c []bool, ait, cit Iterator) (err error) {
	var i, j int
	var validi, validj bool
	var retIsVec bool
	if retIsVec, err = iterCheck2(a, c, ait, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = ait.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if retIsVec {
			j = i
			validj = validi
		} else {
			if j, validj, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj {
			c[j] = a[i] < b
		}
	}
	return

}

// LtSVBool performs c := scalar ̅< vec. The scalar value is broadcasted for the operation.
func LtSVBool[T constraints.Ordered](a T, b []T, c []bool) {
	b = b[:]
	c = c[:len(b)]

	for i := range b {
		c[i] = a < b[i]
	}
}

// LtSVIterBool performs c := scalar ̅< vec. The scalar value is broadcasted for the operation.
func LtSVIterBool[T constraints.Ordered](a T, b []T, c []bool, bit, cit Iterator) (err error) {
	var i, j int
	var validi, validj bool
	var retIsVec bool
	if retIsVec, err = iterCheck2(b, c, bit, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = bit.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if retIsVec {
			j = i
			validj = validi
		} else {
			if j, validj, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj {
			c[j] = a < b[i]
		}
	}
	return

}

// LteVVBool performs c := a ̅<= b.
func LteVVBool[T constraints.Ordered](a, b []T, c []bool) {
	a = a[:]
	b = b[:len(a)]
	c = c[:len(a)]

	for i := range a {
		c[i] = a[i] <= b[i]
	}
}

// LteBCBool performs c := a ̅<= b, using the appropriate indexing that follows a broadcast operation.
func LteBCBool[T constraints.Ordered](a, b []T, c []bool, aShp, bShp, cShp shapes.Shape, aStrides, bStrides []int) {
	for i := range c {
		var idxA, idxB int
		for j := range cShp {
			aDim, bDim := 1, 1
			if j < aShp.Dims() {
				aDim = aShp[j]
			}
			if j < bShp.Dims() {
				bDim = bShp[j]
			}
			idxDim := (i / cShp[j+1:].TotalSize()) % cShp[j]
			if aDim != 1 {
				idxA += (idxDim % aDim) * aStrides[j]
			}
			if bDim != 1 {
				idxB += (idxDim % bDim) * bStrides[j]
			}
		}
		c[i] = a[idxA] <= b[idxB]
	}
}

// LteVVIterBool performs c := a  ̅<= b, where a, b, and c requires the use of an iterator.
func LteVVIterBool[T constraints.Ordered](a, b []T, c []bool, ait, bit, cit Iterator) (err error) {
	var i, j, k int
	var validi, validj, validk bool
	var cisa, cisb bool
	if cisa, cisb, err = iterCheck3(a, b, c, ait, bit, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = ait.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if j, validj, err = bit.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}

		switch {
		case cisa:
			validk = validi
			k = i
		case cisb:
			validk = validj
			k = j
		default:
			if k, validk, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj && validk {
			c[k] = a[i] <= b[j]
		}
	}
	return
}

// LteVSBool performs c := vec ̅<= scalar. The scalar value is broadcasted for the operation.
func LteVSBool[T constraints.Ordered](a []T, b T, c []bool) {
	a = a[:]
	c = c[:len(a)]

	for i := range a {
		c[i] = a[i] <= b
	}
}

// LteVSIterBool performs c := vec ̅<= scalar. The scalar value is broadcasted for the operation.
func LteVSIterBool[T constraints.Ordered](a []T, b T, c []bool, ait, cit Iterator) (err error) {
	var i, j int
	var validi, validj bool
	var retIsVec bool
	if retIsVec, err = iterCheck2(a, c, ait, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = ait.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if retIsVec {
			j = i
			validj = validi
		} else {
			if j, validj, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj {
			c[j] = a[i] <= b
		}
	}
	return

}

// LteSVBool performs c := scalar ̅<= vec. The scalar value is broadcasted for the operation.
func LteSVBool[T constraints.Ordered](a T, b []T, c []bool) {
	b = b[:]
	c = c[:len(b)]

	for i := range b {
		c[i] = a <= b[i]
	}
}

// LteSVIterBool performs c := scalar ̅<= vec. The scalar value is broadcasted for the operation.
func LteSVIterBool[T constraints.Ordered](a T, b []T, c []bool, bit, cit Iterator) (err error) {
	var i, j int
	var validi, validj bool
	var retIsVec bool
	if retIsVec, err = iterCheck2(b, c, bit, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = bit.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if retIsVec {
			j = i
			validj = validi
		} else {
			if j, validj, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj {
			c[j] = a <= b[i]
		}
	}
	return

}

// GtVVBool performs c := a ̅> b.
func GtVVBool[T constraints.Ordered](a, b []T, c []bool) {
	a = a[:]
	b = b[:len(a)]
	c = c[:len(a)]

	for i := range a {
		c[i] = a[i] > b[i]
	}
}

// GtBCBool performs c := a ̅> b, using the appropriate indexing that follows a broadcast operation.
func GtBCBool[T constraints.Ordered](a, b []T, c []bool, aShp, bShp, cShp shapes.Shape, aStrides, bStrides []int) {
	for i := range c {
		var idxA, idxB int
		for j := range cShp {
			aDim, bDim := 1, 1
			if j < aShp.Dims() {
				aDim = aShp[j]
			}
			if j < bShp.Dims() {
				bDim = bShp[j]
			}
			idxDim := (i / cShp[j+1:].TotalSize()) % cShp[j]
			if aDim != 1 {
				idxA += (idxDim % aDim) * aStrides[j]
			}
			if bDim != 1 {
				idxB += (idxDim % bDim) * bStrides[j]
			}
		}
		c[i] = a[idxA] > b[idxB]
	}
}

// GtVVIterBool performs c := a  ̅> b, where a, b, and c requires the use of an iterator.
func GtVVIterBool[T constraints.Ordered](a, b []T, c []bool, ait, bit, cit Iterator) (err error) {
	var i, j, k int
	var validi, validj, validk bool
	var cisa, cisb bool
	if cisa, cisb, err = iterCheck3(a, b, c, ait, bit, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = ait.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if j, validj, err = bit.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}

		switch {
		case cisa:
			validk = validi
			k = i
		case cisb:
			validk = validj
			k = j
		default:
			if k, validk, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj && validk {
			c[k] = a[i] > b[j]
		}
	}
	return
}

// GtVSBool performs c := vec ̅> scalar. The scalar value is broadcasted for the operation.
func GtVSBool[T constraints.Ordered](a []T, b T, c []bool) {
	a = a[:]
	c = c[:len(a)]

	for i := range a {
		c[i] = a[i] > b
	}
}

// GtVSIterBool performs c := vec ̅> scalar. The scalar value is broadcasted for the operation.
func GtVSIterBool[T constraints.Ordered](a []T, b T, c []bool, ait, cit Iterator) (err error) {
	var i, j int
	var validi, validj bool
	var retIsVec bool
	if retIsVec, err = iterCheck2(a, c, ait, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = ait.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if retIsVec {
			j = i
			validj = validi
		} else {
			if j, validj, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj {
			c[j] = a[i] > b
		}
	}
	return

}

// GtSVBool performs c := scalar ̅> vec. The scalar value is broadcasted for the operation.
func GtSVBool[T constraints.Ordered](a T, b []T, c []bool) {
	b = b[:]
	c = c[:len(b)]

	for i := range b {
		c[i] = a > b[i]
	}
}

// GtSVIterBool performs c := scalar ̅> vec. The scalar value is broadcasted for the operation.
func GtSVIterBool[T constraints.Ordered](a T, b []T, c []bool, bit, cit Iterator) (err error) {
	var i, j int
	var validi, validj bool
	var retIsVec bool
	if retIsVec, err = iterCheck2(b, c, bit, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = bit.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if retIsVec {
			j = i
			validj = validi
		} else {
			if j, validj, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj {
			c[j] = a > b[i]
		}
	}
	return

}

// GteVVBool performs c := a ̅>= b.
func GteVVBool[T constraints.Ordered](a, b []T, c []bool) {
	a = a[:]
	b = b[:len(a)]
	c = c[:len(a)]

	for i := range a {
		c[i] = a[i] >= b[i]
	}
}

// GteBCBool performs c := a ̅>= b, using the appropriate indexing that follows a broadcast operation.
func GteBCBool[T constraints.Ordered](a, b []T, c []bool, aShp, bShp, cShp shapes.Shape, aStrides, bStrides []int) {
	for i := range c {
		var idxA, idxB int
		for j := range cShp {
			aDim, bDim := 1, 1
			if j < aShp.Dims() {
				aDim = aShp[j]
			}
			if j < bShp.Dims() {
				bDim = bShp[j]
			}
			idxDim := (i / cShp[j+1:].TotalSize()) % cShp[j]
			if aDim != 1 {
				idxA += (idxDim % aDim) * aStrides[j]
			}
			if bDim != 1 {
				idxB += (idxDim % bDim) * bStrides[j]
			}
		}
		c[i] = a[idxA] >= b[idxB]
	}
}

// GteVVIterBool performs c := a  ̅>= b, where a, b, and c requires the use of an iterator.
func GteVVIterBool[T constraints.Ordered](a, b []T, c []bool, ait, bit, cit Iterator) (err error) {
	var i, j, k int
	var validi, validj, validk bool
	var cisa, cisb bool
	if cisa, cisb, err = iterCheck3(a, b, c, ait, bit, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = ait.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if j, validj, err = bit.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}

		switch {
		case cisa:
			validk = validi
			k = i
		case cisb:
			validk = validj
			k = j
		default:
			if k, validk, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj && validk {
			c[k] = a[i] >= b[j]
		}
	}
	return
}

// GteVSBool performs c := vec ̅>= scalar. The scalar value is broadcasted for the operation.
func GteVSBool[T constraints.Ordered](a []T, b T, c []bool) {
	a = a[:]
	c = c[:len(a)]

	for i := range a {
		c[i] = a[i] >= b
	}
}

// GteVSIterBool performs c := vec ̅>= scalar. The scalar value is broadcasted for the operation.
func GteVSIterBool[T constraints.Ordered](a []T, b T, c []bool, ait, cit Iterator) (err error) {
	var i, j int
	var validi, validj bool
	var retIsVec bool
	if retIsVec, err = iterCheck2(a, c, ait, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = ait.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if retIsVec {
			j = i
			validj = validi
		} else {
			if j, validj, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj {
			c[j] = a[i] >= b
		}
	}
	return

}

// GteSVBool performs c := scalar ̅>= vec. The scalar value is broadcasted for the operation.
func GteSVBool[T constraints.Ordered](a T, b []T, c []bool) {
	b = b[:]
	c = c[:len(b)]

	for i := range b {
		c[i] = a >= b[i]
	}
}

// GteSVIterBool performs c := scalar ̅>= vec. The scalar value is broadcasted for the operation.
func GteSVIterBool[T constraints.Ordered](a T, b []T, c []bool, bit, cit Iterator) (err error) {
	var i, j int
	var validi, validj bool
	var retIsVec bool
	if retIsVec, err = iterCheck2(b, c, bit, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = bit.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if retIsVec {
			j = i
			validj = validi
		} else {
			if j, validj, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj {
			c[j] = a >= b[i]
		}
	}
	return

}

// ElEqVVBool performs c := a ̅== b.
func ElEqVVBool[T comparable](a, b []T, c []bool) {
	a = a[:]
	b = b[:len(a)]
	c = c[:len(a)]

	for i := range a {
		c[i] = a[i] == b[i]
	}
}

// ElEqBCBool performs c := a ̅== b, using the appropriate indexing that follows a broadcast operation.
func ElEqBCBool[T comparable](a, b []T, c []bool, aShp, bShp, cShp shapes.Shape, aStrides, bStrides []int) {
	for i := range c {
		var idxA, idxB int
		for j := range cShp {
			aDim, bDim := 1, 1
			if j < aShp.Dims() {
				aDim = aShp[j]
			}
			if j < bShp.Dims() {
				bDim = bShp[j]
			}
			idxDim := (i / cShp[j+1:].TotalSize()) % cShp[j]
			if aDim != 1 {
				idxA += (idxDim % aDim) * aStrides[j]
			}
			if bDim != 1 {
				idxB += (idxDim % bDim) * bStrides[j]
			}
		}
		c[i] = a[idxA] == b[idxB]
	}
}

// ElEqVVIterBool performs c := a  ̅== b, where a, b, and c requires the use of an iterator.
func ElEqVVIterBool[T comparable](a, b []T, c []bool, ait, bit, cit Iterator) (err error) {
	var i, j, k int
	var validi, validj, validk bool
	var cisa, cisb bool
	if cisa, cisb, err = iterCheck3(a, b, c, ait, bit, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = ait.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if j, validj, err = bit.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}

		switch {
		case cisa:
			validk = validi
			k = i
		case cisb:
			validk = validj
			k = j
		default:
			if k, validk, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj && validk {
			c[k] = a[i] == b[j]
		}
	}
	return
}

// ElEqVSBool performs c := vec ̅== scalar. The scalar value is broadcasted for the operation.
func ElEqVSBool[T comparable](a []T, b T, c []bool) {
	a = a[:]
	c = c[:len(a)]

	for i := range a {
		c[i] = a[i] == b
	}
}

// ElEqVSIterBool performs c := vec ̅== scalar. The scalar value is broadcasted for the operation.
func ElEqVSIterBool[T comparable](a []T, b T, c []bool, ait, cit Iterator) (err error) {
	var i, j int
	var validi, validj bool
	var retIsVec bool
	if retIsVec, err = iterCheck2(a, c, ait, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = ait.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if retIsVec {
			j = i
			validj = validi
		} else {
			if j, validj, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj {
			c[j] = a[i] == b
		}
	}
	return

}

// ElEqSVBool performs c := scalar ̅== vec. The scalar value is broadcasted for the operation.
func ElEqSVBool[T comparable](a T, b []T, c []bool) {
	b = b[:]
	c = c[:len(b)]

	for i := range b {
		c[i] = a == b[i]
	}
}

// ElEqSVIterBool performs c := scalar ̅== vec. The scalar value is broadcasted for the operation.
func ElEqSVIterBool[T comparable](a T, b []T, c []bool, bit, cit Iterator) (err error) {
	var i, j int
	var validi, validj bool
	var retIsVec bool
	if retIsVec, err = iterCheck2(b, c, bit, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = bit.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if retIsVec {
			j = i
			validj = validi
		} else {
			if j, validj, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj {
			c[j] = a == b[i]
		}
	}
	return

}

// ElNeVVBool performs c := a ̅!= b.
func ElNeVVBool[T comparable](a, b []T, c []bool) {
	a = a[:]
	b = b[:len(a)]
	c = c[:len(a)]

	for i := range a {
		c[i] = a[i] != b[i]
	}
}

// ElNeBCBool performs c := a ̅!= b, using the appropriate indexing that follows a broadcast operation.
func ElNeBCBool[T comparable](a, b []T, c []bool, aShp, bShp, cShp shapes.Shape, aStrides, bStrides []int) {
	for i := range c {
		var idxA, idxB int
		for j := range cShp {
			aDim, bDim := 1, 1
			if j < aShp.Dims() {
				aDim = aShp[j]
			}
			if j < bShp.Dims() {
				bDim = bShp[j]
			}
			idxDim := (i / cShp[j+1:].TotalSize()) % cShp[j]
			if aDim != 1 {
				idxA += (idxDim % aDim) * aStrides[j]
			}
			if bDim != 1 {
				idxB += (idxDim % bDim) * bStrides[j]
			}
		}
		c[i] = a[idxA] != b[idxB]
	}
}

// ElNeVVIterBool performs c := a  ̅!= b, where a, b, and c requires the use of an iterator.
func ElNeVVIterBool[T comparable](a, b []T, c []bool, ait, bit, cit Iterator) (err error) {
	var i, j, k int
	var validi, validj, validk bool
	var cisa, cisb bool
	if cisa, cisb, err = iterCheck3(a, b, c, ait, bit, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = ait.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if j, validj, err = bit.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}

		switch {
		case cisa:
			validk = validi
			k = i
		case cisb:
			validk = validj
			k = j
		default:
			if k, validk, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj && validk {
			c[k] = a[i] != b[j]
		}
	}
	return
}

// ElNeVSBool performs c := vec ̅!= scalar. The scalar value is broadcasted for the operation.
func ElNeVSBool[T comparable](a []T, b T, c []bool) {
	a = a[:]
	c = c[:len(a)]

	for i := range a {
		c[i] = a[i] != b
	}
}

// ElNeVSIterBool performs c := vec ̅!= scalar. The scalar value is broadcasted for the operation.
func ElNeVSIterBool[T comparable](a []T, b T, c []bool, ait, cit Iterator) (err error) {
	var i, j int
	var validi, validj bool
	var retIsVec bool
	if retIsVec, err = iterCheck2(a, c, ait, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = ait.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if retIsVec {
			j = i
			validj = validi
		} else {
			if j, validj, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj {
			c[j] = a[i] != b
		}
	}
	return

}

// ElNeSVBool performs c := scalar ̅!= vec. The scalar value is broadcasted for the operation.
func ElNeSVBool[T comparable](a T, b []T, c []bool) {
	b = b[:]
	c = c[:len(b)]

	for i := range b {
		c[i] = a != b[i]
	}
}

// ElNeSVIterBool performs c := scalar ̅!= vec. The scalar value is broadcasted for the operation.
func ElNeSVIterBool[T comparable](a T, b []T, c []bool, bit, cit Iterator) (err error) {
	var i, j int
	var validi, validj bool
	var retIsVec bool
	if retIsVec, err = iterCheck2(b, c, bit, cit); err != nil {
		return errors.Wrapf(err, internal.ThisFn())
	}
loop:
	for {
		if i, validi, err = bit.NextValidity(); err != nil {
			err = handleNoOp(err)
			break
		}
		if retIsVec {
			j = i
			validj = validi
		} else {
			if j, validj, err = cit.NextValidity(); err != nil {
				err = handleNoOp(err)
				break loop
			}
		}

		if validi && validj {
			c[j] = a != b[i]
		}
	}
	return

}
