// Code generated by genlib3. DO NOT EDIT

package dense

import (
	"gorgonia.org/dtype"
	"gorgonia.org/tensor"
	"gorgonia.org/tensor/internal/errors"
)

// Lt performs `t < u`
func (t *Dense[DT]) Lt(u *Dense[DT], opts ...FuncOpt) (retVal DescWithStorage, err error) {
	e := getEngine[DT](t, u)
	if err = check(checkFlags(e, t, u)); err != nil {
		return nil, errors.Wrapf(err, errors.FailedSanity, errors.ThisFn())
	}
	tShp := t.Shape()
	uShp := u.Shape()
	expShape := largestShape(tShp, uShp)

	var prepper tensor.DescFuncOptHandler[DT]
	var ok bool
	if prepper, ok = e.(tensor.DescFuncOptHandler[DT]); !ok {
		return nil, errors.Errorf(errors.EngineSupport, e, prepper, errors.ThisFn())
	}

	var fo Option
	if retVal, fo, err = prepper.HandleFuncOptsDesc(t, expShape, opts...); err != nil {
		return nil, errors.Wrapf(err, errors.FailedFuncOpt, errors.ThisFn())
	}
	if fo.Incr {
		return nil, errors.Errorf("Unable to Incr for Lt")
	}

	asBool := fo.AsType == dtype.Bool
	ctx := fo.Ctx

	var cmper tensor.Ord[DT, *Dense[DT]]
	if cmper, ok = e.(tensor.Ord[DT, *Dense[DT]]); !ok {
		return nil, errors.Errorf(errors.EngineSupport, e, cmper, errors.ThisFn())
	}

	if fo.Broadcast {
		// create Autobroadcast shape
		newAPT, newAPU := tensor.CalcBroadcastShapes(t.Info(), u.Info())
		if err = tensor.CheckBroadcastable(newAPT.Shape(), newAPU.Shape()); err != nil {
			return nil, errors.Wrapf(err, errors.FailedSanity, errors.ThisFn())
		}

		err = cmper.LtBroadcastable(ctx, t, u, retVal, !asBool, newAPT, newAPU)
		return
	}

	if err = cmper.Lt(ctx, t, u, retVal, !asBool); err != nil {
		return nil, err
	}
	return retVal, nil
}

// Lte performs `t <= u`
func (t *Dense[DT]) Lte(u *Dense[DT], opts ...FuncOpt) (retVal DescWithStorage, err error) {
	e := getEngine[DT](t, u)
	if err = check(checkFlags(e, t, u)); err != nil {
		return nil, errors.Wrapf(err, errors.FailedSanity, errors.ThisFn())
	}
	tShp := t.Shape()
	uShp := u.Shape()
	expShape := largestShape(tShp, uShp)

	var prepper tensor.DescFuncOptHandler[DT]
	var ok bool
	if prepper, ok = e.(tensor.DescFuncOptHandler[DT]); !ok {
		return nil, errors.Errorf(errors.EngineSupport, e, prepper, errors.ThisFn())
	}

	var fo Option
	if retVal, fo, err = prepper.HandleFuncOptsDesc(t, expShape, opts...); err != nil {
		return nil, errors.Wrapf(err, errors.FailedFuncOpt, errors.ThisFn())
	}
	if fo.Incr {
		return nil, errors.Errorf("Unable to Incr for Lt")
	}

	asBool := fo.AsType == dtype.Bool
	ctx := fo.Ctx

	var cmper tensor.Ord[DT, *Dense[DT]]
	if cmper, ok = e.(tensor.Ord[DT, *Dense[DT]]); !ok {
		return nil, errors.Errorf(errors.EngineSupport, e, cmper, errors.ThisFn())
	}

	if fo.Broadcast {
		// create Autobroadcast shape
		newAPT, newAPU := tensor.CalcBroadcastShapes(t.Info(), u.Info())
		if err = tensor.CheckBroadcastable(newAPT.Shape(), newAPU.Shape()); err != nil {
			return nil, errors.Wrapf(err, errors.FailedSanity, errors.ThisFn())
		}

		err = cmper.LteBroadcastable(ctx, t, u, retVal, !asBool, newAPT, newAPU)
		return
	}

	if err = cmper.Lte(ctx, t, u, retVal, !asBool); err != nil {
		return nil, err
	}
	return retVal, nil
}

// Gt performs `t > u`
func (t *Dense[DT]) Gt(u *Dense[DT], opts ...FuncOpt) (retVal DescWithStorage, err error) {
	e := getEngine[DT](t, u)
	if err = check(checkFlags(e, t, u)); err != nil {
		return nil, errors.Wrapf(err, errors.FailedSanity, errors.ThisFn())
	}
	tShp := t.Shape()
	uShp := u.Shape()
	expShape := largestShape(tShp, uShp)

	var prepper tensor.DescFuncOptHandler[DT]
	var ok bool
	if prepper, ok = e.(tensor.DescFuncOptHandler[DT]); !ok {
		return nil, errors.Errorf(errors.EngineSupport, e, prepper, errors.ThisFn())
	}

	var fo Option
	if retVal, fo, err = prepper.HandleFuncOptsDesc(t, expShape, opts...); err != nil {
		return nil, errors.Wrapf(err, errors.FailedFuncOpt, errors.ThisFn())
	}
	if fo.Incr {
		return nil, errors.Errorf("Unable to Incr for Lt")
	}

	asBool := fo.AsType == dtype.Bool
	ctx := fo.Ctx

	var cmper tensor.FullOrd[DT, *Dense[DT]]
	if cmper, ok = e.(tensor.FullOrd[DT, *Dense[DT]]); !ok {
		return nil, errors.Errorf(errors.EngineSupport, e, cmper, errors.ThisFn())
	}

	if fo.Broadcast {
		// create Autobroadcast shape
		newAPT, newAPU := tensor.CalcBroadcastShapes(t.Info(), u.Info())
		if err = tensor.CheckBroadcastable(newAPT.Shape(), newAPU.Shape()); err != nil {
			return nil, errors.Wrapf(err, errors.FailedSanity, errors.ThisFn())
		}

		err = cmper.GtBroadcastable(ctx, t, u, retVal, !asBool, newAPT, newAPU)
		return
	}

	if err = cmper.Gt(ctx, t, u, retVal, !asBool); err != nil {
		return nil, err
	}
	return retVal, nil
}

// Gte performs `t >= u`
func (t *Dense[DT]) Gte(u *Dense[DT], opts ...FuncOpt) (retVal DescWithStorage, err error) {
	e := getEngine[DT](t, u)
	if err = check(checkFlags(e, t, u)); err != nil {
		return nil, errors.Wrapf(err, errors.FailedSanity, errors.ThisFn())
	}
	tShp := t.Shape()
	uShp := u.Shape()
	expShape := largestShape(tShp, uShp)

	var prepper tensor.DescFuncOptHandler[DT]
	var ok bool
	if prepper, ok = e.(tensor.DescFuncOptHandler[DT]); !ok {
		return nil, errors.Errorf(errors.EngineSupport, e, prepper, errors.ThisFn())
	}

	var fo Option
	if retVal, fo, err = prepper.HandleFuncOptsDesc(t, expShape, opts...); err != nil {
		return nil, errors.Wrapf(err, errors.FailedFuncOpt, errors.ThisFn())
	}
	if fo.Incr {
		return nil, errors.Errorf("Unable to Incr for Lt")
	}

	asBool := fo.AsType == dtype.Bool
	ctx := fo.Ctx

	var cmper tensor.FullOrd[DT, *Dense[DT]]
	if cmper, ok = e.(tensor.FullOrd[DT, *Dense[DT]]); !ok {
		return nil, errors.Errorf(errors.EngineSupport, e, cmper, errors.ThisFn())
	}

	if fo.Broadcast {
		// create Autobroadcast shape
		newAPT, newAPU := tensor.CalcBroadcastShapes(t.Info(), u.Info())
		if err = tensor.CheckBroadcastable(newAPT.Shape(), newAPU.Shape()); err != nil {
			return nil, errors.Wrapf(err, errors.FailedSanity, errors.ThisFn())
		}

		err = cmper.GteBroadcastable(ctx, t, u, retVal, !asBool, newAPT, newAPU)
		return
	}

	if err = cmper.Gte(ctx, t, u, retVal, !asBool); err != nil {
		return nil, err
	}
	return retVal, nil
}

// ElEq performs `t == u`
func (t *Dense[DT]) ElEq(u *Dense[DT], opts ...FuncOpt) (retVal DescWithStorage, err error) {
	e := getEngine[DT](t, u)
	if err = check(checkFlags(e, t, u)); err != nil {
		return nil, errors.Wrapf(err, errors.FailedSanity, errors.ThisFn())
	}
	tShp := t.Shape()
	uShp := u.Shape()
	expShape := largestShape(tShp, uShp)

	var prepper tensor.DescFuncOptHandler[DT]
	var ok bool
	if prepper, ok = e.(tensor.DescFuncOptHandler[DT]); !ok {
		return nil, errors.Errorf(errors.EngineSupport, e, prepper, errors.ThisFn())
	}

	var fo Option
	if retVal, fo, err = prepper.HandleFuncOptsDesc(t, expShape, opts...); err != nil {
		return nil, errors.Wrapf(err, errors.FailedFuncOpt, errors.ThisFn())
	}
	if fo.Incr {
		return nil, errors.Errorf("Unable to Incr for Lt")
	}

	asBool := fo.AsType == dtype.Bool
	ctx := fo.Ctx

	var cmper tensor.Comparer[DT, *Dense[DT]]
	if cmper, ok = e.(tensor.Comparer[DT, *Dense[DT]]); !ok {
		return nil, errors.Errorf(errors.EngineSupport, e, cmper, errors.ThisFn())
	}

	if fo.Broadcast {
		// create Autobroadcast shape
		newAPT, newAPU := tensor.CalcBroadcastShapes(t.Info(), u.Info())
		if err = tensor.CheckBroadcastable(newAPT.Shape(), newAPU.Shape()); err != nil {
			return nil, errors.Wrapf(err, errors.FailedSanity, errors.ThisFn())
		}

		err = cmper.ElEqBroadcastable(ctx, t, u, retVal, !asBool, newAPT, newAPU)
		return
	}

	if err = cmper.ElEq(ctx, t, u, retVal, !asBool); err != nil {
		return nil, err
	}
	return retVal, nil
}

// Ne performs `t != u`
func (t *Dense[DT]) Ne(u *Dense[DT], opts ...FuncOpt) (retVal DescWithStorage, err error) {
	e := getEngine[DT](t, u)
	if err = check(checkFlags(e, t, u)); err != nil {
		return nil, errors.Wrapf(err, errors.FailedSanity, errors.ThisFn())
	}
	tShp := t.Shape()
	uShp := u.Shape()
	expShape := largestShape(tShp, uShp)

	var prepper tensor.DescFuncOptHandler[DT]
	var ok bool
	if prepper, ok = e.(tensor.DescFuncOptHandler[DT]); !ok {
		return nil, errors.Errorf(errors.EngineSupport, e, prepper, errors.ThisFn())
	}

	var fo Option
	if retVal, fo, err = prepper.HandleFuncOptsDesc(t, expShape, opts...); err != nil {
		return nil, errors.Wrapf(err, errors.FailedFuncOpt, errors.ThisFn())
	}
	if fo.Incr {
		return nil, errors.Errorf("Unable to Incr for Lt")
	}

	asBool := fo.AsType == dtype.Bool
	ctx := fo.Ctx

	var cmper tensor.Comparer[DT, *Dense[DT]]
	if cmper, ok = e.(tensor.Comparer[DT, *Dense[DT]]); !ok {
		return nil, errors.Errorf(errors.EngineSupport, e, cmper, errors.ThisFn())
	}

	if fo.Broadcast {
		// create Autobroadcast shape
		newAPT, newAPU := tensor.CalcBroadcastShapes(t.Info(), u.Info())
		if err = tensor.CheckBroadcastable(newAPT.Shape(), newAPU.Shape()); err != nil {
			return nil, errors.Wrapf(err, errors.FailedSanity, errors.ThisFn())
		}

		err = cmper.NeBroadcastable(ctx, t, u, retVal, !asBool, newAPT, newAPU)
		return
	}

	if err = cmper.Ne(ctx, t, u, retVal, !asBool); err != nil {
		return nil, err
	}
	return retVal, nil
}
