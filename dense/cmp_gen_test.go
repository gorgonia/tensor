// Code generated by genlib3. DO NOT EDIT

package dense

import (
	"testing"

	"github.com/stretchr/testify/assert"
	"gorgonia.org/tensor"
	"gorgonia.org/tensor/internal"
)

func genLtTrans[DT internal.OrderedNum](t *testing.T, _ *assert.Assertions) any {
	return func(a, b, c *Dense[DT], sameShape bool) bool {

		_, ok1 := a.Engine().(tensor.Ord[DT])
		weAB := !a.IsNativelyAccessible() || !b.IsNativelyAccessible() || !ok1 || !a.Shape().Eq(b.Shape())
		ab, err := a.Lt(b)
		if err2, retEarly := qcErrCheck(t, "Lt - a∙b", a, b, weAB, err); retEarly {
			return err2 == nil
		}

		_, ok2 := b.Engine().(tensor.Ord[DT])
		weBC := !b.IsNativelyAccessible() || !c.IsNativelyAccessible() || !ok2 || !b.Shape().Eq(c.Shape())
		bc, err := b.Lt(c)
		if err, retEarly := qcErrCheck(t, "Lt - b∙c", b, c, weBC, err); retEarly {
			return err == nil
		}

		ac, err := a.Lt(c)
		weAC := !a.IsNativelyAccessible() || !b.IsNativelyAccessible() || !ok1 || !a.Shape().Eq(c.Shape())
		if err, retEarly := qcErrCheck(t, "Lt - a∙c", a, c, weAC, err); retEarly {
			return err == nil
		}

		abD := ab.(tensor.Basic[bool]).Data()
		bcD := bc.(tensor.Basic[bool]).Data()
		acD := ac.(tensor.Basic[bool]).Data()
		for i := range abD {
			if abD[i] && bcD[i] && !acD[i] {
				return false
			}
		}
		return true
	}
}

func genLtTransCisDT[DT internal.OrderedNum](t *testing.T, _ *assert.Assertions) any {
	return func(a, b, c *Dense[DT], sameShape bool) bool {

		_, ok1 := a.Engine().(tensor.Ord[DT])
		weAB := !a.IsNativelyAccessible() || !b.IsNativelyAccessible() || !ok1 || !a.Shape().Eq(b.Shape())
		ab, err := a.Lt(b, As(a.Dtype()))
		if err2, retEarly := qcErrCheck(t, "Lt - a∙b", a, b, weAB, err); retEarly {
			return err2 == nil
		}

		_, ok2 := b.Engine().(tensor.Ord[DT])
		weBC := !b.IsNativelyAccessible() || !c.IsNativelyAccessible() || !ok2 || !b.Shape().Eq(c.Shape())
		bc, err := b.Lt(c, As(b.Dtype()))
		if err, retEarly := qcErrCheck(t, "Lt - b∙c", b, c, weBC, err); retEarly {
			return err == nil
		}

		ac, err := a.Lt(c, As(a.Dtype()))
		weAC := !a.IsNativelyAccessible() || !b.IsNativelyAccessible() || !ok1 || !a.Shape().Eq(c.Shape())
		if err, retEarly := qcErrCheck(t, "Lt - a∙c", a, c, weAC, err); retEarly {
			return err == nil
		}

		return !boolNums3Eq(ab.(*Dense[DT]).Data(), bc.(*Dense[DT]).Data(), ac.(*Dense[DT]).Data())
	}
}

func TestDense_Lt(t *testing.T) {
	qcHelper[uint](t, nil, genLtTrans[uint])
	qcHelper[uint](t, nil, genLtTransCisDT[uint])
	qcHelper[uint8](t, nil, genLtTrans[uint8])
	qcHelper[uint8](t, nil, genLtTransCisDT[uint8])
	qcHelper[uint16](t, nil, genLtTrans[uint16])
	qcHelper[uint16](t, nil, genLtTransCisDT[uint16])
	qcHelper[uint32](t, nil, genLtTrans[uint32])
	qcHelper[uint32](t, nil, genLtTransCisDT[uint32])
	qcHelper[uint64](t, nil, genLtTrans[uint64])
	qcHelper[uint64](t, nil, genLtTransCisDT[uint64])
	qcHelper[int](t, nil, genLtTrans[int])
	qcHelper[int](t, nil, genLtTransCisDT[int])
	qcHelper[int8](t, nil, genLtTrans[int8])
	qcHelper[int8](t, nil, genLtTransCisDT[int8])
	qcHelper[int16](t, nil, genLtTrans[int16])
	qcHelper[int16](t, nil, genLtTransCisDT[int16])
	qcHelper[int32](t, nil, genLtTrans[int32])
	qcHelper[int32](t, nil, genLtTransCisDT[int32])
	qcHelper[int64](t, nil, genLtTrans[int64])
	qcHelper[int64](t, nil, genLtTransCisDT[int64])
	qcHelper[float32](t, nil, genLtTrans[float32])
	qcHelper[float32](t, nil, genLtTransCisDT[float32])
	qcHelper[float64](t, nil, genLtTrans[float64])
	qcHelper[float64](t, nil, genLtTransCisDT[float64])
}
func genLteTrans[DT internal.OrderedNum](t *testing.T, _ *assert.Assertions) any {
	return func(a, b, c *Dense[DT], sameShape bool) bool {

		_, ok1 := a.Engine().(tensor.Ord[DT])
		weAB := !a.IsNativelyAccessible() || !b.IsNativelyAccessible() || !ok1 || !a.Shape().Eq(b.Shape())
		ab, err := a.Lte(b)
		if err2, retEarly := qcErrCheck(t, "Lte - a∙b", a, b, weAB, err); retEarly {
			return err2 == nil
		}

		_, ok2 := b.Engine().(tensor.Ord[DT])
		weBC := !b.IsNativelyAccessible() || !c.IsNativelyAccessible() || !ok2 || !b.Shape().Eq(c.Shape())
		bc, err := b.Lte(c)
		if err, retEarly := qcErrCheck(t, "Lte - b∙c", b, c, weBC, err); retEarly {
			return err == nil
		}

		ac, err := a.Lte(c)
		weAC := !a.IsNativelyAccessible() || !b.IsNativelyAccessible() || !ok1 || !a.Shape().Eq(c.Shape())
		if err, retEarly := qcErrCheck(t, "Lte - a∙c", a, c, weAC, err); retEarly {
			return err == nil
		}

		abD := ab.(tensor.Basic[bool]).Data()
		bcD := bc.(tensor.Basic[bool]).Data()
		acD := ac.(tensor.Basic[bool]).Data()
		for i := range abD {
			if abD[i] && bcD[i] && !acD[i] {
				return false
			}
		}
		return true
	}
}

func genLteTransCisDT[DT internal.OrderedNum](t *testing.T, _ *assert.Assertions) any {
	return func(a, b, c *Dense[DT], sameShape bool) bool {

		_, ok1 := a.Engine().(tensor.Ord[DT])
		weAB := !a.IsNativelyAccessible() || !b.IsNativelyAccessible() || !ok1 || !a.Shape().Eq(b.Shape())
		ab, err := a.Lte(b, As(a.Dtype()))
		if err2, retEarly := qcErrCheck(t, "Lte - a∙b", a, b, weAB, err); retEarly {
			return err2 == nil
		}

		_, ok2 := b.Engine().(tensor.Ord[DT])
		weBC := !b.IsNativelyAccessible() || !c.IsNativelyAccessible() || !ok2 || !b.Shape().Eq(c.Shape())
		bc, err := b.Lte(c, As(b.Dtype()))
		if err, retEarly := qcErrCheck(t, "Lte - b∙c", b, c, weBC, err); retEarly {
			return err == nil
		}

		ac, err := a.Lte(c, As(a.Dtype()))
		weAC := !a.IsNativelyAccessible() || !b.IsNativelyAccessible() || !ok1 || !a.Shape().Eq(c.Shape())
		if err, retEarly := qcErrCheck(t, "Lte - a∙c", a, c, weAC, err); retEarly {
			return err == nil
		}

		return !boolNums3Eq(ab.(*Dense[DT]).Data(), bc.(*Dense[DT]).Data(), ac.(*Dense[DT]).Data())
	}
}

func TestDense_Lte(t *testing.T) {
	qcHelper[uint](t, nil, genLteTrans[uint])
	qcHelper[uint](t, nil, genLteTransCisDT[uint])
	qcHelper[uint8](t, nil, genLteTrans[uint8])
	qcHelper[uint8](t, nil, genLteTransCisDT[uint8])
	qcHelper[uint16](t, nil, genLteTrans[uint16])
	qcHelper[uint16](t, nil, genLteTransCisDT[uint16])
	qcHelper[uint32](t, nil, genLteTrans[uint32])
	qcHelper[uint32](t, nil, genLteTransCisDT[uint32])
	qcHelper[uint64](t, nil, genLteTrans[uint64])
	qcHelper[uint64](t, nil, genLteTransCisDT[uint64])
	qcHelper[int](t, nil, genLteTrans[int])
	qcHelper[int](t, nil, genLteTransCisDT[int])
	qcHelper[int8](t, nil, genLteTrans[int8])
	qcHelper[int8](t, nil, genLteTransCisDT[int8])
	qcHelper[int16](t, nil, genLteTrans[int16])
	qcHelper[int16](t, nil, genLteTransCisDT[int16])
	qcHelper[int32](t, nil, genLteTrans[int32])
	qcHelper[int32](t, nil, genLteTransCisDT[int32])
	qcHelper[int64](t, nil, genLteTrans[int64])
	qcHelper[int64](t, nil, genLteTransCisDT[int64])
	qcHelper[float32](t, nil, genLteTrans[float32])
	qcHelper[float32](t, nil, genLteTransCisDT[float32])
	qcHelper[float64](t, nil, genLteTrans[float64])
	qcHelper[float64](t, nil, genLteTransCisDT[float64])
}
func genGtTrans[DT internal.OrderedNum](t *testing.T, _ *assert.Assertions) any {
	return func(a, b, c *Dense[DT], sameShape bool) bool {

		_, ok1 := a.Engine().(tensor.FullOrd[DT])
		weAB := !a.IsNativelyAccessible() || !b.IsNativelyAccessible() || !ok1 || !a.Shape().Eq(b.Shape())
		ab, err := a.Gt(b)
		if err2, retEarly := qcErrCheck(t, "Gt - a∙b", a, b, weAB, err); retEarly {
			return err2 == nil
		}

		_, ok2 := b.Engine().(tensor.FullOrd[DT])
		weBC := !b.IsNativelyAccessible() || !c.IsNativelyAccessible() || !ok2 || !b.Shape().Eq(c.Shape())
		bc, err := b.Gt(c)
		if err, retEarly := qcErrCheck(t, "Gt - b∙c", b, c, weBC, err); retEarly {
			return err == nil
		}

		ac, err := a.Gt(c)
		weAC := !a.IsNativelyAccessible() || !b.IsNativelyAccessible() || !ok1 || !a.Shape().Eq(c.Shape())
		if err, retEarly := qcErrCheck(t, "Gt - a∙c", a, c, weAC, err); retEarly {
			return err == nil
		}

		abD := ab.(tensor.Basic[bool]).Data()
		bcD := bc.(tensor.Basic[bool]).Data()
		acD := ac.(tensor.Basic[bool]).Data()
		for i := range abD {
			if abD[i] && bcD[i] && !acD[i] {
				return false
			}
		}
		return true
	}
}

func genGtTransCisDT[DT internal.OrderedNum](t *testing.T, _ *assert.Assertions) any {
	return func(a, b, c *Dense[DT], sameShape bool) bool {

		_, ok1 := a.Engine().(tensor.FullOrd[DT])
		weAB := !a.IsNativelyAccessible() || !b.IsNativelyAccessible() || !ok1 || !a.Shape().Eq(b.Shape())
		ab, err := a.Gt(b, As(a.Dtype()))
		if err2, retEarly := qcErrCheck(t, "Gt - a∙b", a, b, weAB, err); retEarly {
			return err2 == nil
		}

		_, ok2 := b.Engine().(tensor.FullOrd[DT])
		weBC := !b.IsNativelyAccessible() || !c.IsNativelyAccessible() || !ok2 || !b.Shape().Eq(c.Shape())
		bc, err := b.Gt(c, As(b.Dtype()))
		if err, retEarly := qcErrCheck(t, "Gt - b∙c", b, c, weBC, err); retEarly {
			return err == nil
		}

		ac, err := a.Gt(c, As(a.Dtype()))
		weAC := !a.IsNativelyAccessible() || !b.IsNativelyAccessible() || !ok1 || !a.Shape().Eq(c.Shape())
		if err, retEarly := qcErrCheck(t, "Gt - a∙c", a, c, weAC, err); retEarly {
			return err == nil
		}

		return !boolNums3Eq(ab.(*Dense[DT]).Data(), bc.(*Dense[DT]).Data(), ac.(*Dense[DT]).Data())
	}
}

func TestDense_Gt(t *testing.T) {
	qcHelper[uint](t, nil, genGtTrans[uint])
	qcHelper[uint](t, nil, genGtTransCisDT[uint])
	qcHelper[uint8](t, nil, genGtTrans[uint8])
	qcHelper[uint8](t, nil, genGtTransCisDT[uint8])
	qcHelper[uint16](t, nil, genGtTrans[uint16])
	qcHelper[uint16](t, nil, genGtTransCisDT[uint16])
	qcHelper[uint32](t, nil, genGtTrans[uint32])
	qcHelper[uint32](t, nil, genGtTransCisDT[uint32])
	qcHelper[uint64](t, nil, genGtTrans[uint64])
	qcHelper[uint64](t, nil, genGtTransCisDT[uint64])
	qcHelper[int](t, nil, genGtTrans[int])
	qcHelper[int](t, nil, genGtTransCisDT[int])
	qcHelper[int8](t, nil, genGtTrans[int8])
	qcHelper[int8](t, nil, genGtTransCisDT[int8])
	qcHelper[int16](t, nil, genGtTrans[int16])
	qcHelper[int16](t, nil, genGtTransCisDT[int16])
	qcHelper[int32](t, nil, genGtTrans[int32])
	qcHelper[int32](t, nil, genGtTransCisDT[int32])
	qcHelper[int64](t, nil, genGtTrans[int64])
	qcHelper[int64](t, nil, genGtTransCisDT[int64])
	qcHelper[float32](t, nil, genGtTrans[float32])
	qcHelper[float32](t, nil, genGtTransCisDT[float32])
	qcHelper[float64](t, nil, genGtTrans[float64])
	qcHelper[float64](t, nil, genGtTransCisDT[float64])
}
func genGteTrans[DT internal.OrderedNum](t *testing.T, _ *assert.Assertions) any {
	return func(a, b, c *Dense[DT], sameShape bool) bool {

		_, ok1 := a.Engine().(tensor.FullOrd[DT])
		weAB := !a.IsNativelyAccessible() || !b.IsNativelyAccessible() || !ok1 || !a.Shape().Eq(b.Shape())
		ab, err := a.Gte(b)
		if err2, retEarly := qcErrCheck(t, "Gte - a∙b", a, b, weAB, err); retEarly {
			return err2 == nil
		}

		_, ok2 := b.Engine().(tensor.FullOrd[DT])
		weBC := !b.IsNativelyAccessible() || !c.IsNativelyAccessible() || !ok2 || !b.Shape().Eq(c.Shape())
		bc, err := b.Gte(c)
		if err, retEarly := qcErrCheck(t, "Gte - b∙c", b, c, weBC, err); retEarly {
			return err == nil
		}

		ac, err := a.Gte(c)
		weAC := !a.IsNativelyAccessible() || !b.IsNativelyAccessible() || !ok1 || !a.Shape().Eq(c.Shape())
		if err, retEarly := qcErrCheck(t, "Gte - a∙c", a, c, weAC, err); retEarly {
			return err == nil
		}

		abD := ab.(tensor.Basic[bool]).Data()
		bcD := bc.(tensor.Basic[bool]).Data()
		acD := ac.(tensor.Basic[bool]).Data()
		for i := range abD {
			if abD[i] && bcD[i] && !acD[i] {
				return false
			}
		}
		return true
	}
}

func genGteTransCisDT[DT internal.OrderedNum](t *testing.T, _ *assert.Assertions) any {
	return func(a, b, c *Dense[DT], sameShape bool) bool {

		_, ok1 := a.Engine().(tensor.FullOrd[DT])
		weAB := !a.IsNativelyAccessible() || !b.IsNativelyAccessible() || !ok1 || !a.Shape().Eq(b.Shape())
		ab, err := a.Gte(b, As(a.Dtype()))
		if err2, retEarly := qcErrCheck(t, "Gte - a∙b", a, b, weAB, err); retEarly {
			return err2 == nil
		}

		_, ok2 := b.Engine().(tensor.FullOrd[DT])
		weBC := !b.IsNativelyAccessible() || !c.IsNativelyAccessible() || !ok2 || !b.Shape().Eq(c.Shape())
		bc, err := b.Gte(c, As(b.Dtype()))
		if err, retEarly := qcErrCheck(t, "Gte - b∙c", b, c, weBC, err); retEarly {
			return err == nil
		}

		ac, err := a.Gte(c, As(a.Dtype()))
		weAC := !a.IsNativelyAccessible() || !b.IsNativelyAccessible() || !ok1 || !a.Shape().Eq(c.Shape())
		if err, retEarly := qcErrCheck(t, "Gte - a∙c", a, c, weAC, err); retEarly {
			return err == nil
		}

		return !boolNums3Eq(ab.(*Dense[DT]).Data(), bc.(*Dense[DT]).Data(), ac.(*Dense[DT]).Data())
	}
}

func TestDense_Gte(t *testing.T) {
	qcHelper[uint](t, nil, genGteTrans[uint])
	qcHelper[uint](t, nil, genGteTransCisDT[uint])
	qcHelper[uint8](t, nil, genGteTrans[uint8])
	qcHelper[uint8](t, nil, genGteTransCisDT[uint8])
	qcHelper[uint16](t, nil, genGteTrans[uint16])
	qcHelper[uint16](t, nil, genGteTransCisDT[uint16])
	qcHelper[uint32](t, nil, genGteTrans[uint32])
	qcHelper[uint32](t, nil, genGteTransCisDT[uint32])
	qcHelper[uint64](t, nil, genGteTrans[uint64])
	qcHelper[uint64](t, nil, genGteTransCisDT[uint64])
	qcHelper[int](t, nil, genGteTrans[int])
	qcHelper[int](t, nil, genGteTransCisDT[int])
	qcHelper[int8](t, nil, genGteTrans[int8])
	qcHelper[int8](t, nil, genGteTransCisDT[int8])
	qcHelper[int16](t, nil, genGteTrans[int16])
	qcHelper[int16](t, nil, genGteTransCisDT[int16])
	qcHelper[int32](t, nil, genGteTrans[int32])
	qcHelper[int32](t, nil, genGteTransCisDT[int32])
	qcHelper[int64](t, nil, genGteTrans[int64])
	qcHelper[int64](t, nil, genGteTransCisDT[int64])
	qcHelper[float32](t, nil, genGteTrans[float32])
	qcHelper[float32](t, nil, genGteTransCisDT[float32])
	qcHelper[float64](t, nil, genGteTrans[float64])
	qcHelper[float64](t, nil, genGteTransCisDT[float64])
}
func genElEqTrans[DT internal.OrderedNum](t *testing.T, _ *assert.Assertions) any {
	return func(a, b, c *Dense[DT], sameShape bool) bool {

		_, ok1 := a.Engine().(tensor.Comparer[DT])
		weAB := !a.IsNativelyAccessible() || !b.IsNativelyAccessible() || !ok1 || !a.Shape().Eq(b.Shape())
		ab, err := a.ElEq(b)
		if err2, retEarly := qcErrCheck(t, "ElEq - a∙b", a, b, weAB, err); retEarly {
			return err2 == nil
		}

		_, ok2 := b.Engine().(tensor.Comparer[DT])
		weBC := !b.IsNativelyAccessible() || !c.IsNativelyAccessible() || !ok2 || !b.Shape().Eq(c.Shape())
		bc, err := b.ElEq(c)
		if err, retEarly := qcErrCheck(t, "ElEq - b∙c", b, c, weBC, err); retEarly {
			return err == nil
		}

		ac, err := a.ElEq(c)
		weAC := !a.IsNativelyAccessible() || !b.IsNativelyAccessible() || !ok1 || !a.Shape().Eq(c.Shape())
		if err, retEarly := qcErrCheck(t, "ElEq - a∙c", a, c, weAC, err); retEarly {
			return err == nil
		}

		abD := ab.(tensor.Basic[bool]).Data()
		bcD := bc.(tensor.Basic[bool]).Data()
		acD := ac.(tensor.Basic[bool]).Data()
		for i := range abD {
			if abD[i] && bcD[i] && !acD[i] {
				return false
			}
		}
		return true
	}
}

func genElEqTransCisDT[DT internal.OrderedNum](t *testing.T, _ *assert.Assertions) any {
	return func(a, b, c *Dense[DT], sameShape bool) bool {

		_, ok1 := a.Engine().(tensor.Comparer[DT])
		weAB := !a.IsNativelyAccessible() || !b.IsNativelyAccessible() || !ok1 || !a.Shape().Eq(b.Shape())
		ab, err := a.ElEq(b, As(a.Dtype()))
		if err2, retEarly := qcErrCheck(t, "ElEq - a∙b", a, b, weAB, err); retEarly {
			return err2 == nil
		}

		_, ok2 := b.Engine().(tensor.Comparer[DT])
		weBC := !b.IsNativelyAccessible() || !c.IsNativelyAccessible() || !ok2 || !b.Shape().Eq(c.Shape())
		bc, err := b.ElEq(c, As(b.Dtype()))
		if err, retEarly := qcErrCheck(t, "ElEq - b∙c", b, c, weBC, err); retEarly {
			return err == nil
		}

		ac, err := a.ElEq(c, As(a.Dtype()))
		weAC := !a.IsNativelyAccessible() || !b.IsNativelyAccessible() || !ok1 || !a.Shape().Eq(c.Shape())
		if err, retEarly := qcErrCheck(t, "ElEq - a∙c", a, c, weAC, err); retEarly {
			return err == nil
		}

		return !boolNums3Eq(ab.(*Dense[DT]).Data(), bc.(*Dense[DT]).Data(), ac.(*Dense[DT]).Data())
	}
}

func TestDense_ElEq(t *testing.T) {
	qcHelper[uint](t, nil, genElEqTrans[uint])
	qcHelper[uint](t, nil, genElEqTransCisDT[uint])
	qcHelper[uint8](t, nil, genElEqTrans[uint8])
	qcHelper[uint8](t, nil, genElEqTransCisDT[uint8])
	qcHelper[uint16](t, nil, genElEqTrans[uint16])
	qcHelper[uint16](t, nil, genElEqTransCisDT[uint16])
	qcHelper[uint32](t, nil, genElEqTrans[uint32])
	qcHelper[uint32](t, nil, genElEqTransCisDT[uint32])
	qcHelper[uint64](t, nil, genElEqTrans[uint64])
	qcHelper[uint64](t, nil, genElEqTransCisDT[uint64])
	qcHelper[int](t, nil, genElEqTrans[int])
	qcHelper[int](t, nil, genElEqTransCisDT[int])
	qcHelper[int8](t, nil, genElEqTrans[int8])
	qcHelper[int8](t, nil, genElEqTransCisDT[int8])
	qcHelper[int16](t, nil, genElEqTrans[int16])
	qcHelper[int16](t, nil, genElEqTransCisDT[int16])
	qcHelper[int32](t, nil, genElEqTrans[int32])
	qcHelper[int32](t, nil, genElEqTransCisDT[int32])
	qcHelper[int64](t, nil, genElEqTrans[int64])
	qcHelper[int64](t, nil, genElEqTransCisDT[int64])
	qcHelper[float32](t, nil, genElEqTrans[float32])
	qcHelper[float32](t, nil, genElEqTransCisDT[float32])
	qcHelper[float64](t, nil, genElEqTrans[float64])
	qcHelper[float64](t, nil, genElEqTransCisDT[float64])
}
func genElNeTrans[DT internal.OrderedNum](t *testing.T, _ *assert.Assertions) any {
	return func(a, b, c *Dense[DT], sameShape bool) bool {

		_, ok1 := a.Engine().(tensor.Comparer[DT])
		weAB := !a.IsNativelyAccessible() || !b.IsNativelyAccessible() || !ok1 || !a.Shape().Eq(b.Shape())
		ab, err := a.ElNe(b)
		if err2, retEarly := qcErrCheck(t, "ElNe - a∙b", a, b, weAB, err); retEarly {
			return err2 == nil
		}

		_, ok2 := b.Engine().(tensor.Comparer[DT])
		weBC := !b.IsNativelyAccessible() || !c.IsNativelyAccessible() || !ok2 || !b.Shape().Eq(c.Shape())
		bc, err := b.ElNe(c)
		if err, retEarly := qcErrCheck(t, "ElNe - b∙c", b, c, weBC, err); retEarly {
			return err == nil
		}

		ac, err := a.ElNe(c)
		weAC := !a.IsNativelyAccessible() || !b.IsNativelyAccessible() || !ok1 || !a.Shape().Eq(c.Shape())
		if err, retEarly := qcErrCheck(t, "ElNe - a∙c", a, c, weAC, err); retEarly {
			return err == nil
		}

		abD := ab.(tensor.Basic[bool]).Data()
		bcD := bc.(tensor.Basic[bool]).Data()
		acD := ac.(tensor.Basic[bool]).Data()
		for i := range abD {
			if abD[i] && bcD[i] && !acD[i] {
				return false
			}
		}
		return true
	}
}

func genElNeTransCisDT[DT internal.OrderedNum](t *testing.T, _ *assert.Assertions) any {
	return func(a, b, c *Dense[DT], sameShape bool) bool {

		_, ok1 := a.Engine().(tensor.Comparer[DT])
		weAB := !a.IsNativelyAccessible() || !b.IsNativelyAccessible() || !ok1 || !a.Shape().Eq(b.Shape())
		ab, err := a.ElNe(b, As(a.Dtype()))
		if err2, retEarly := qcErrCheck(t, "ElNe - a∙b", a, b, weAB, err); retEarly {
			return err2 == nil
		}

		_, ok2 := b.Engine().(tensor.Comparer[DT])
		weBC := !b.IsNativelyAccessible() || !c.IsNativelyAccessible() || !ok2 || !b.Shape().Eq(c.Shape())
		bc, err := b.ElNe(c, As(b.Dtype()))
		if err, retEarly := qcErrCheck(t, "ElNe - b∙c", b, c, weBC, err); retEarly {
			return err == nil
		}

		ac, err := a.ElNe(c, As(a.Dtype()))
		weAC := !a.IsNativelyAccessible() || !b.IsNativelyAccessible() || !ok1 || !a.Shape().Eq(c.Shape())
		if err, retEarly := qcErrCheck(t, "ElNe - a∙c", a, c, weAC, err); retEarly {
			return err == nil
		}

		return !boolNums3Eq(ab.(*Dense[DT]).Data(), bc.(*Dense[DT]).Data(), ac.(*Dense[DT]).Data())
	}
}

func TestDense_ElNe(t *testing.T) {
	qcHelper[uint](t, nil, genElNeTrans[uint])
	qcHelper[uint](t, nil, genElNeTransCisDT[uint])
	qcHelper[uint8](t, nil, genElNeTrans[uint8])
	qcHelper[uint8](t, nil, genElNeTransCisDT[uint8])
	qcHelper[uint16](t, nil, genElNeTrans[uint16])
	qcHelper[uint16](t, nil, genElNeTransCisDT[uint16])
	qcHelper[uint32](t, nil, genElNeTrans[uint32])
	qcHelper[uint32](t, nil, genElNeTransCisDT[uint32])
	qcHelper[uint64](t, nil, genElNeTrans[uint64])
	qcHelper[uint64](t, nil, genElNeTransCisDT[uint64])
	qcHelper[int](t, nil, genElNeTrans[int])
	qcHelper[int](t, nil, genElNeTransCisDT[int])
	qcHelper[int8](t, nil, genElNeTrans[int8])
	qcHelper[int8](t, nil, genElNeTransCisDT[int8])
	qcHelper[int16](t, nil, genElNeTrans[int16])
	qcHelper[int16](t, nil, genElNeTransCisDT[int16])
	qcHelper[int32](t, nil, genElNeTrans[int32])
	qcHelper[int32](t, nil, genElNeTransCisDT[int32])
	qcHelper[int64](t, nil, genElNeTrans[int64])
	qcHelper[int64](t, nil, genElNeTransCisDT[int64])
	qcHelper[float32](t, nil, genElNeTrans[float32])
	qcHelper[float32](t, nil, genElNeTransCisDT[float32])
	qcHelper[float64](t, nil, genElNeTrans[float64])
	qcHelper[float64](t, nil, genElNeTransCisDT[float64])
}
